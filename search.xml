<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hexo Next博客优化]]></title>
      <url>%2F2017%2F01%2F25%2Fhexo-blog-seo%2F</url>
      <content type="text"><![CDATA[进一步打造自己的Blog。 搜索服务安装 hexo-generator-searchdb 在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑主题配置文件_config.yml，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 开启打赏功能主题的_config.yml: 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /img/archives/ss.pngalipay: /img/archives/ss.png 字体全局字体：编辑 next/source/css/_variables/custom.styl, 1$font-size-base = 16px; 背景图片next/source/css/_custom/custom.styl文件: 1body &#123; background:url(/images/backGround.jpg);&#125; 背景颜色定义颜色变量：themes/next/source/css/_variables/custom.styl 1234// 背景颜色$body-bg-color = #f5f5d5;$header-bg-color = #f5f5d5;$footer-bg-color = #f5f5d5; 定义完后，其实body的背景已经换了。 头部背景色： themes/next/source/css/_schemes/Mist/sidebar/_header.styl： 1.header &#123; background: $header-bg-color; &#125; footer背景色： 123456.footer &#123; margin-top: 80px; padding: 10px 0; background: $footer-bg-color; color: $grey-dim;&#125; 代码风格主题_config.yml: 1highlight_theme: night blue 内容宽度themes/next/source/css/_variables/custom.styl 1234// 修改成你期望的宽度$content-desktop = 900px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1100px 文章目录序号关闭主题_config.yml: 123456#Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: false 无序列表不喜欢空心的，我们换成实心的列表： 文章列表：source/css/_common/components/post/post-expand.styl:1ul li &#123; list-style: disc; &#125; 页面列表：next/source/css/_custom/custom.styl: 123ul &#123;list-style-type: disc; // 空心圆，实心圆为 disc&#125; 参考：https://github.com/iissnan/hexo-theme-next/issues/559 文章访问次数主题_config.yml: 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;浏览 page_pv_footer: 次]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[应用程序安装流程]]></title>
      <url>%2F2017%2F01%2F18%2Fpackage-install%2F</url>
      <content type="text"><![CDATA[本文介绍APK的安装流程。 安装流程图APK安装流程，总体可以下图流程，用ProcessOn画的，凑合看： 从上图我们可以看到apk安装到最后都会调用到这个flow： PMS.scanPackageTracedLI =&gt; PMS.scanPackageLI =&gt; PMS.scanPackageDirtyLI 关于这个flow，之前的博客有详细介绍过，本文不再展开 : https://maoao530.github.io/2017/01/10/packagemanager/ 后续的博文会根据这张图展开说明。 APK文件结构APK(Android Package)，可以看做是一个zip压缩包，可以通过解压缩工具解开，其文件结构如下： 目录 or 文件 描述 assert 存放的原生资源文件,通过AssetManager类访问 lib native库文件 META-INF 存放签名信息，用来保证APK包的完整性和系统的安全。系统安装APK时，应用管理器会按照对应算法对包里文件做校验，如果校验结果与META-INF中内容不一致，则不会安装这个APK。 res 种资源文件系统会在R.java里面自动生成该资源文件的ID，所以访问这种资源文件比较简单，通过R.XXX.ID即可 AndroidManifest.xml 每个应用都必须定义和包含，描述应用的名字、版本权限、引用的库文件等信息。apk中的AndroidManifest.xml经过压缩，可以通过AXMLPrinter2工具解开。 classes.dex 是JAVA源码编译后生成的JAVA字节码文件。但Android使用的dalvik虚拟机与标准的JAVA虚拟机不兼容，dex文件与class文件相比，不论是文件结构还是opcode都不一样。 resources.arsc 编译后的二进制资源文件。 APK安装方法APK有下面4种安装方法： 方法 描述 开机过程中安装 开机时完成，没有安装界面，如系统应用、其它预置应用 adb工具安装 没有安装界面，adb install/push xxxx.apk 第三方应用安装 通过packageinstaller.apk进行安装，有安装界面，如打开文件管理器并点击sdk卡里APK文件 网络下载应用安装 通过google market应用完成，没有安装界面 简单说明下apk安装的基本过程： 拷贝目标apk到指定文件目录 调用scanPackageLI为apk文件在系统中注册信息 应用程序安装过程上述几种安装方法最终都通过PackageManagerService.scanPackageLI完成，总结起来大致有以下三种方式： adb push：PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件frameworks\base\services\java\com\android\server\pm\PackageManagerService.java adb install：安装入口函数为Pm.runInstallframeworks\base\cmds\pm\src\com\android\commands\pm\Pm.java 网络下载应用安装和第三方应用安装：安装入口函数为ApplicationPackageManager.installPackageframeworks\base\core\java\android\app\ApplicationPackageManager.java 接下来我们来分别详细说明这些安装流程： adb pushAndroid 4.4平台，PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件。如果是添加事件，则调用scanPackageLI，并使用updatePermissionsLPw授权；如果是删除事件则调用removePackageLI移除该apk的相关信息。最后都要调用writeLPr重新保存相关信息到packages.xml。 关于AppDirObserver具体如何监听的，可以查看：AppDirObserver 不过我在android 7.0 sdk里面没有看到这个类，难道7.0把这个功能砍了？手头没有7.0平台，不好验证。 我猜测现在通过adb push apk到data/app或者system/app的apk，如果这个监听的功能砍了，那么应该是会通过reboot重启系统，走PMS.main流程，scanDir–&gt;scanPackageLI去安装apk。 以上待填坑。 adb installadb install 的安装方式，会调用system/core/adb/commandline.cpp中的adb_commandline函数：12345adb_commandline install_app_legacy or install_app pm_command send_shell_command Pm.runInstall() 这个过程会把apk文件copy到data/local/tmp/目录下，然后向shell服务发送pm命令安装apk，最后调用Pm.runInstall()方法来安装apk。 pm.runInstallframeworks\base\cmds\pm\src\com\android\commands\pm\Pm.java 12345678910111213141516171819202122232425262728293031private int runInstall() throws RemoteException &#123; final InstallParams params = makeInstallParams(); // 1. 创建session final int sessionId = doCreateSession(params.sessionParams, params.installerPackageName, params.userId); try &#123; final String inPath = nextArg(); if (inPath == null &amp;&amp; params.sessionParams.sizeBytes == 0) &#123; System.err.println("Error: must either specify a package size or an APK file"); return 1; &#125; // 2. 写session if (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, "base.apk", false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; // 3. 提交Session if (doCommitSession(sessionId, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; System.out.println("Success"); return 0; &#125; finally &#123; try &#123; mInstaller.abandonSession(sessionId); &#125; catch (Exception ignore) &#123; &#125; &#125;&#125; 从上面的代码来看，runInstall主要进行了三件事，即创建session、对session进行写操作，最后提交session。 doCreateSession实际调用的是PackageInstallerService的createSession，这个过程主要是为APK安装做好准备工作，例如权限检查、目的临时文件的创建等， 最终创建出PackageInstallerSession对象。PackageInstallerSession可以看做是”安装APK”这个请求的封装，其中包含了处理这个请求需要的一些信息。实际上PackageInstallerSession不仅是分装请求的对象，其自身还是个服务端。 doWriteSession通过PackageInstallerSession将/data/local/tmp的apk拷贝到终端目录内。 doCommitSessiondoWriteSession结束后，如果没有出现任何错误，那么APK源文件已经copy到目的地址了，doCommitSession最终会调用到PMS.installStage来安装apk，调用流程如下： PackageInstallerSession.commit ==&gt; commitLocked(); ==&gt; PMS.installStage() PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler： 1234567891011121314151617181920212223242526272829303132333435void installStage(String packageName, File stagedDir, String stagedCid, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, Certificate[][] certificates) &#123; if (DEBUG_EPHEMERAL) &#123; if ((sessionParams.installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0) &#123; Slog.d(TAG, "Ephemeral install of " + packageName); &#125; &#125; final VerificationInfo verificationInfo = new VerificationInfo( sessionParams.originatingUri, sessionParams.referrerUri, sessionParams.originatingUid, installerUid); final OriginInfo origin; if (stagedDir != null) &#123; origin = OriginInfo.fromStagedFile(stagedDir); &#125; else &#123; origin = OriginInfo.fromStagedContainer(stagedCid); &#125; final Message msg = mHandler.obtainMessage(INIT_COPY); final InstallParams params = new InstallParams(origin, null, observer, sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid, verificationInfo, user, sessionParams.abiOverride, sessionParams.grantedRuntimePermissions, certificates); params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params)); msg.obj = params; Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "installStage", System.identityHashCode(msg.obj)); Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(msg.obj)); mHandler.sendMessage(msg);&#125; PackageHandler用于处理apk的安装请求等消息，后面分析。 ApplicationPackageManager网络下载应用安装或者通过第三方应用安装，最终都会通过ApplicationPackageManager.installPackage来安装： 123456789101112131415161718192021public void installPackage(Uri packageURI, PackageInstallObserver observer, int flags, String installerPackageName) &#123; installCommon(packageURI, observer, flags, installerPackageName, mContext.getUserId()); &#125;private void installCommon(Uri packageURI, PackageInstallObserver observer, int flags, String installerPackageName, int userId) &#123; if (!"file".equals(packageURI.getScheme())) &#123; throw new UnsupportedOperationException("Only file:// URIs are supported"); &#125; final String originPath = packageURI.getPath(); try &#123; // PMS.installPackageAsUser mPM.installPackageAsUser(originPath, observer.getBinder(), flags, installerPackageName, userId); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler: 12345678910111213141516171819@Overridepublic void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) &#123; ... final Message msg = mHandler.obtainMessage(INIT_COPY); final VerificationInfo verificationInfo = new VerificationInfo( null /*originatingUri*/, null /*referrer*/, -1 /*originatingUid*/, callingUid); final InstallParams params = new InstallParams(origin, null /*moveInfo*/, observer, installFlags, installerPackageName, null /*volumeUuid*/, verificationInfo, user, null /*packageAbiOverride*/, null /*grantedPermissions*/, null /*certificates*/); params.setTraceMethod("installAsUser").setTraceCookie(System.identityHashCode(params)); msg.obj = params; mHandler.sendMessage(msg); ....&#125; PackageHandler用于处理apk的安装请求等消息，后面分析。 PackageHanlder PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler INIT_COPYPackageHandler用于处理apk的安装请求等消息，在PMS构造函数中有初始化。实际处理消息的函数为doHandleMessage，我们来看看INIT_COPY的处理流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class PackageHandler extends Handler &#123; ... void doHandleMessage(Message msg) &#123; switch (msg.what) &#123; case INIT_COPY: &#123; //这里取出的其实就是InstallParams HandlerParams params = (HandlerParams) msg.obj; //idx为当前等待处理处理的安装请求的个数 int idx = mPendingInstalls.size(); ............ //初始时，mBound的值为false if (!mBound) &#123; ............ // If this is the only one pending we might // have to bind to the service again. //连接安装服务 if (!connectToService()) &#123; .................. &#125; else &#123; // Once we bind to the service, the first // pending request will be processed. //绑定服务成功后，将新的请求加入到mPendingIntalls中，等待处理 mPendingInstalls.add(idx, params); &#125; &#125; else &#123; //如果之前已经绑定过服务，同样将新的请求加入到mPendingIntalls中，等待处理 mPendingInstalls.add(idx, params); // Already bound to the service. Just make // sure we trigger off processing the first request. if (idx == 0) &#123; //如果是第一个请求，则直接发送事件MCS_BOUND，触发处理流程 mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125; break; &#125; &#125; &#125; ...&#125; INIT_COPY主要是将新的请求加入到mPendingIntalls中，等待MCS_BOUND阶段处理。 MCS_BOUNDINIT_COPY最后会发送MCS_BOUND消息触发接下来的流程，MCS_BOUND对应的处理流程同样定义于doHandleMessage中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void doHandleMessage(Message msg) &#123; ....... case MCS_BOUND: &#123; ........ if (msg.obj != null) &#123; mContainerService = (IMediaContainerService) msg.obj; ....... &#125; if (mContainerService == null) &#123; if (!mBound) &#123; // Something seriously wrong since we are not bound and we are not // waiting for connection. Bail out. ............ &#125; else &#123; Slog.w(TAG, "Waiting to connect to media container service"); &#125; // 请求队列mPendingInstalls不为空 &#125; else if (mPendingInstalls.size() &gt; 0) &#123; HandlerParams params = mPendingInstalls.get(0); if (params != null) &#123; ........ //调用参数的startCopy函数处理安装请求 if (params.startCopy()) &#123; ........ // Delete pending install if (mPendingInstalls.size() &gt; 0) &#123; mPendingInstalls.remove(0); &#125; if (mPendingInstalls.size() == 0) &#123; if (mBound) &#123; .......... removeMessages(MCS_UNBIND); Message ubmsg = obtainMessage(MCS_UNBIND); // Unbind after a little delay, to avoid // continual thrashing. sendMessageDelayed(ubmsg, 10000); &#125; &#125; else &#123; // There are more pending requests in queue. // Just post MCS_BOUND message to trigger processing // of next pending install. ...... mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125; ......... &#125; &#125; else &#123; // Should never happen ideally. Slog.w(TAG, "Empty queue"); &#125; break; &#125;.......&#125; 这一段代码比较好理解: 如果mPendingInstalls不为空，调用InstallParams.startCopy函数处理安装请求。 接着如果mPendingInstalls不为空，发送MCS_BOUND继续处理下一个，直到队列为空。 如果队列为空，则等待一段时间后，发送MCS_UNBIND消息断开与安装服务的绑定。 startCopy/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java InstallParams继承HandlerParams，实际调用的是HandlerParams.startCopy: 1234567891011121314151617181920212223242526final boolean startCopy() &#123; boolean res; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, "startCopy " + mUser + ": " + this); if (++mRetries &gt; MAX_RETRIES) &#123; Slog.w(TAG, "Failed to invoke remote methods on default container service. Giving up"); mHandler.sendEmptyMessage(MCS_GIVE_UP); handleServiceError(); return false; &#125; else &#123; // 调用handleStartCopy()处理 handleStartCopy(); Slog.i(TAG, "Apk copy done"); res = true; &#125; &#125; catch (RemoteException e) &#123; if (DEBUG_INSTALL) Slog.i(TAG, "Posting install MCS_RECONNECT"); mHandler.sendEmptyMessage(MCS_RECONNECT); res = false; &#125; // handleReturnCode(); return res;&#125; PMS将先后调用handleStartCopy和handleReturnCode来完成主要的工作。 handleStartCopyhandleStartCopy函数在HandleParams抽象类定义，在其子类InstallParams来实现，我们看看与实际安装相关的handleStartCopy函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243public void handleStartCopy() throws RemoteException &#123; int ret = PackageManager.INSTALL_SUCCEEDED; // 决定是安装在手机内还是sdcard中，设置对应标志位 if (origin.staged) &#123; if (origin.file != null) &#123; installFlags |= PackageManager.INSTALL_INTERNAL; installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL; &#125; else if (origin.cid != null) &#123; installFlags |= PackageManager.INSTALL_EXTERNAL; installFlags &amp;= ~PackageManager.INSTALL_INTERNAL; &#125; else &#123; throw new IllegalStateException("Invalid stage location"); &#125; &#125; ... // 检查APK的安装位置是否正确 if (onInt &amp;&amp; onSd) &#123; // Check if both bits are set. Slog.w(TAG, "Conflicting flags specified for installing on both internal and external"); ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else if (onSd &amp;&amp; ephemeral) &#123; Slog.w(TAG, "Conflicting flags specified for installing ephemeral on external"); ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else &#123; ... &#125; ... // createInstallArgs用于创建一个安装参数对象 final InstallArgs args = createInstallArgs(this); if (ret == PackageManager.INSTALL_SUCCEEDED) &#123; ... // 调用InstallArgs的copyApk函数 ret = args.copyApk(mContainerService, true); &#125; &#125; mRet = ret;&#125; InstallParams$handleStartCopy()主要功能是获取安装位置信息以及复制apk到指定位置。抽象类InstallArgs中的copyApk负责复制APK文件，具体实现在子类FileInstallArgs和SdInstallArgs里面。 handleReturnCodeInstallParams$handleReturnCode()中，调用processPendingInstall方法处理安装： 12345678void handleReturnCode() &#123; // If mArgs is null, then MCS couldn't be reached. When it // reconnects, it will try again to install. At that point, this // will succeed. if (mArgs != null) &#123; processPendingInstall(mArgs, mRet); &#125;&#125; processPendingInstall主要的安装流程都在这个方法里面: PMS.processPendingInstall 12345678910111213141516171819202122232425262728293031323334private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123; mHandler.post(new Runnable() &#123; public void run() &#123; mHandler.removeCallbacks(this); // Result object to be returned PackageInstalledInfo res = new PackageInstalledInfo(); res.setReturnCode(currentStatus); res.uid = -1; res.pkg = null; res.removedInfo = null; if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; //1、预安装，检查包状态，确保环境ok，如果环境不ok，那么会清理拷贝的文件 args.doPreInstall(res.returnCode); synchronized (mInstallLock) &#123; //2、安装，调用installPackageTracedLI进行安装 installPackageTracedLI(args, res); &#125; //3、安装收尾 args.doPostInstall(res.returnCode, res.uid); &#125; if (!doRestore) &#123; ....... //4、生成一个POST_INSTALL消息给PackageHanlder Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0); mHandler.sendMessage(msg); &#125; &#125; &#125;);&#125; 安装过程放在一个线程里面，处理流程是预安装-安装-安装收尾-发送 POST_INSTALL消息： 预安装：检查当前安装包的状态以及确保SDCARD的挂载，并返回状态信息。在安装前确保安装环境的可靠。 安装：对mInstallLock加锁，表明同时只能有一个安装包进行安装；然后调用installPackageTracedLI完成具体安装操作。 安装收尾： 检查状态，如果安装不成功，删除掉相关目录文件。 发送POST_INSTALL消息：该消息由PackageHandler接收。POST_INSTALL的主要工作其实还是通过广播、回调接口通知系统中的其它组件，有新的Pacakge安装或发生了改变。 从上面我们可以知道，具体安装apk的函数是PMS.installPackageTracedLI。 installPackageTracedLIPMS.installPackageTracedLI函数： 12345678private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) &#123; try &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "installPackage"); installPackageLI(args, res); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; installPackageLI继续PMS.installPackageLI： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void installPackageLI(InstallArgs args, PackageInstalledInfo res) &#123; // PackageParser对象 PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setDisplayMetrics(mMetrics); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage"); final PackageParser.Package pkg; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, "Start parsing apk: " + installerPackageName); // 1.开始解析我们的package pkg = pp.parsePackage(tmpPackageFile, parseFlags); if (DEBUG_INSTALL) Slog.i(TAG, "Parsing done for apk: " + installerPackageName); &#125; catch (PackageParserException e) &#123; res.setError("Failed parse during installPackageLI", e); return; &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; ... //2. 加载证书，获取签名信息 try &#123; // either use what we've been given or parse directly from the APK if (args.certificates != null) &#123; try &#123; PackageParser.populateCertificates(pkg, args.certificates); &#125; catch (PackageParserException e) &#123; PackageParser.collectCertificates(pkg, parseFlags); &#125; &#125; else &#123; PackageParser.collectCertificates(pkg, parseFlags); &#125; &#125; catch (PackageParserException e) &#123; res.setError("Failed collect during installPackageLI", e); return; &#125; ... synchronized (mPackages) &#123; // 3.检测packages是否存在 if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) &#123; ... replace = true; &#125; else if (mPackages.containsKey(pkgName)) &#123; ... replace = true; if (DEBUG_INSTALL) Slog.d(TAG, "Replace existing pacakge: " + pkgName); &#125; ... &#125; &#125; ... try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) &#123; if (replace) &#123; // 4.更新已经存在的packages replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res); &#125; else &#123; // 5.安装新的packages installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res); &#125; &#125;...&#125; 这个函数过程比较长，主要做了几件事： PackageParser$parsePackage，主要是解析APK的AndroidManifest.xml，将每个标签对应的信息添加到Package的相关列表中，如将下的信息添加到Package的activities列表等。 加载apk证书，获取签名信息 检查目前安装的APK是否在系统中已存在: 已存在，则调用replacePackageLIF进行替换安装。 不存在，否则调用installNewPackageLIF进行安装。 replacePackageLIF如果需要替换的是系统APP，则调用Settings$disableSystemPackageLPw来disable旧的APK；如果替换的是非系统APP，则调用deletePackageLI删除旧的APK。 因为这个过程实在太差，没有必要贴出来一一分析，我来简化一下flow，有兴趣的读者可以深入跟进： 12345678910111213141516171819202122replacePackageLIF replaceSystemPackageLIF // 系统 pkg removePackageLI disableSystemPackageLPw clearAppDataLIF scanPackageTracedLI //安装apk scanPackageLI scanPackageDirtyLI updateSettingsLI updatePermissionsLPw mSettings.writeLPr(); replaceNonSystemPackageLIF // 非系统 pkg deletePackageLIF clearAppDataLIF clearAppProfilesLIF scanPackageTracedLI // 安装apk scanPackageLI scanPackageDirtyLI updateSettingsLI updatePermissionsLPw mSettings.writeLPr(); 不管是更新系统还是非系统apk，都会先清除之前的packages信息，然后通过scanPackageTracedLI去安装apk，安装完后更新permissions和setting，最后通过writeLPr更新packages.xml。 关于scanPackageTracedLI和Settings.writeLPr();我有在上一篇blog讲过，可以回去看看。 installNewPackageLIFPMS.installNewPackageLIF用于安装新的apk： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void installNewPackageLIF(PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, String installerPackageName, String volumeUuid, PackageInstalledInfo res) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "installNewPackage"); // Remember this for later, in case we need to rollback this install String pkgName = pkg.packageName; if (DEBUG_INSTALL) Slog.d(TAG, "installNewPackageLI: " + pkg); // package已经存在 synchronized(mPackages) &#123; if (mSettings.mRenamedPackages.containsKey(pkgName)) &#123; // A package with the same name is already installed, though // it has been renamed to an older name. The package we // are trying to install should be installed as an update to // the existing one, but that has not been requested, so bail. res.setError(INSTALL_FAILED_ALREADY_EXISTS, "Attempt to re-install " + pkgName + " without first uninstalling package running as " + mSettings.mRenamedPackages.get(pkgName)); return; &#125; if (mPackages.containsKey(pkgName)) &#123; // Don't allow installation over an existing package with the same name. res.setError(INSTALL_FAILED_ALREADY_EXISTS, "Attempt to re-install " + pkgName + " without first uninstalling."); return; &#125; &#125; try &#123; // 1. 安装apk PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, System.currentTimeMillis(), user); // 2. 更新setting updateSettingsLI(newPackage, installerPackageName, null, res, user); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; prepareAppDataAfterInstallLIF(newPackage); &#125; else &#123; // Remove package from internal structures, but keep around any // data that might have already existed deletePackageLIF(pkgName, UserHandle.ALL, false, null, PackageManager.DELETE_KEEP_DATA, res.removedInfo, true, null); &#125; &#125; catch (PackageManagerException e) &#123; res.setError("Package couldn't be installed in " + pkg.codePath, e); &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; installNewPackageLIF会调用scanPackageTracedLI去安装apk，最终会调用scanPackageLI-&gt;scanPackageDirtyLI实际去安装apk。 由于之前有描述过，便不再叙述。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PackageManagerService启动流程]]></title>
      <url>%2F2017%2F01%2F10%2Fpackagemanager%2F</url>
      <content type="text"><![CDATA[本文介绍PackageManagerService启动流程。 相关源码:123456789101112frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.javaframeworks/base/services/core/java/com/android/server/pm/PackageInstallerService.javaframeworks/base/services/core/java/com/android/server/pm/Settings.javaframeworks/base/services/core/java/com/android/server/pm/Installer.javaframeworks/base/services/core/java/com/android/server/SystemConfig.javaframeworks/base/core/java/android/content/pm/PackageManager.javaframeworks/base/core/java/android/content/pm/IPackageManager.aidlframeworks/base/core/java/android/content/pm/PackageParser.javaframeworks/base/core/java/com/android/internal/os/InstallerConnection.javaframeworks/base/cmds/pm/src/com/android/commands/pm/Pm.java system_server启动PMSAndroid的所有Java服务都是通过system_server进程启动的，并且驻留在system_server进程中。SystemServer进程在启动时，通过创建一个ServerThread线程来启动所有服务，现在先来看看Android服务中PackageManagerService服务启动过程。 /frameworks/base/services/java/com/android/server/SystemServer.java startBootstrapServices()system_server的startBootstrapServices()函数会启动一些引导服务，该方法所创建的服务： ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， SensorService服务。 其中我们需要的PackageManagerService就在这里启动，我们来看看startBootstrapServices()是如何启动PMS的： 12345678910111213141516171819202122232425262728293031private void startBootstrapServices() &#123; //启动installer服务 Installer installer = mSystemServiceManager.startService(Installer.class); // We need the default display before we can initialize the package manager. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); //处于加密状态则仅仅解析核心应用 // Only run "core" apps if we're encrypting the device. String cryptState = SystemProperties.get("vold.decrypt"); if (ENCRYPTING_STATE.equals(cryptState)) &#123; Slog.w(TAG, "Detected encryption in progress - only parsing core apps"); mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; Slog.w(TAG, "Device encrypted - only parsing core apps"); mOnlyCore = true; &#125; // 创建PMS对象 - 启动入口 traceBeginAndSlog("StartPackageManagerService"); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); // 是否首次启动 mFirstBoot = mPackageManagerService.isFirstBoot(); // 获取PackageManager mPackageManager = mSystemContext.getPackageManager(); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);&#125; startOtherServices()另外，system_server的startOtherServices()方法会启动其他服务，这个函数也会对PMS作一些操作： 12345678910111213141516171819202122private void startOtherServices() &#123; ...... if (!mOnlyCore) &#123; ........ try &#123; //将调用performDexOpt:Performs dexopt on the set of packages mPackageManagerService.updatePackagesIfNeeded(); &#125;....... ........ try &#123; //执行Fstrim，执行磁盘维护操作，未看到详细的资料 //可能类似于TRIM技术，将标记为删除的文件，彻底从硬盘上移除 //而不是等到写入时再移除，目的是提高写入时效率 mPackageManagerService.performFstrimIfNeeded(); &#125;......... ....... try &#123; mPackageManagerService.systemReady(); &#125;........ ....... &#125;&#125; 从上面的代码可以看出，PMS启动后将参与一些系统优化的工作，然后调用SystemReady函数通知系统进入就绪状态。 整个system_server进程启动过程，涉及PMS服务的主要几个动作如下: PMS.main() PMS.performDexOpt() PMS.systemReady() 本文主要介绍PMS.main()流程，即PackageManagerService启动流程。 PMS.main入口PackageManagerService.main过程主要是创建PMS服务，并注册到ServiceManager大管家： 123456789101112131415161718public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); // 创建PMS对象 PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); // Disable any carrier apps. We do this very early in boot to prevent the apps from being // disabled after already being started. CarrierAppUtils.disableCarrierAppsUntilPrivileged(context.getOpPackageName(), m, UserHandle.USER_SYSTEM); // 添加到ServiceManager ServiceManager.addService("package", m); return m;&#125; PMS构造函数 - 分析 new PackageManagerService(context, installer, factoryTest, onlyCore); 创建PMS对象的过程，就是执行PMS的构造函数，PMS构造函数比较长，我们把这个过程分成几个阶段： BOOT_PROGRESS_PMS_START, BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, BOOT_PROGRESS_PMS_DATA_SCAN_START, BOOT_PROGRESS_PMS_SCAN_END, BOOT_PROGRESS_PMS_READY, PMS构造函数里面，在每个阶段开始的时候，都会往Eventlog里面打Tag，比如像这样： 1EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis()); 接下来分别说说这几个阶段。 PMS_STARTBOOT_PROGRESS_PMS_START阶段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// 输出event logEventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());/** M: Mtprof tool @&#123; *///mMTPROFDisable = "1".equals(SystemProperties.get("ro.mtprof.disable"));mMTPROFDisable = false;addBootEvent("Android:PackageManagerService_Start");/** @&#125; */if (mSdkVersion &lt;= 0) &#123; Slog.w(TAG, "**** ro.build.version.sdk not set!");&#125;mContext = context;mFactoryTest = factoryTest;mOnlyCore = onlyCore;// DisplayMetrics是一个描述界面显示，尺寸，分辨率，密度的类。mMetrics = new DisplayMetrics();// Settings是Android的全局管理者，用于协助PMS保存所有的安装包信息mSettings = new Settings(mPackages);mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.log", LOG_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw("android.uid.shell", SHELL_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);// 获取debug.separate_processes属性// 如果设置了这个属性，那么会强制应用程序组件在自己的进程中运行。// 一般情况下不会设置这个属性String separateProcesses = SystemProperties.get("debug.separate_processes");if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) &#123; // 所有process都设置这个属性 if ("*".equals(separateProcesses)) &#123; mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES; mSeparateProcesses = null; Slog.w(TAG, "Running with debug.separate_processes: * (ALL)"); &#125; // 个别的process设置这个属性 else &#123; mDefParseFlags = 0; mSeparateProcesses = separateProcesses.split(","); Slog.w(TAG, "Running with debug.separate_processes: " + separateProcesses); &#125;&#125; else &#123; // 不设置这个属性,一般情况下会走这 mDefParseFlags = 0; mSeparateProcesses = null;&#125;// 保存Installer对象mInstaller = installer;// //用于dex优化mPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context, "*dexopt*");mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());mOnPermissionChangeListeners = new OnPermissionChangeListeners( FgThread.get().getLooper());// 获取默认的显示信息，保存到mMetricsgetDefaultDisplayMetrics(context, mMetrics);// 获取系统配置信息SystemConfig systemConfig = SystemConfig.getInstance();mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions();mAvailableFeatures = systemConfig.getAvailableFeatures();synchronized (mInstallLock) &#123;// writersynchronized (mPackages) &#123; //创建名为“PackageManager”的handler线程 mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/); mHandlerThread.start(); // 建立PackageHandler消息循环，用于处理外部的安装请求等消息 // 比如如adb install、packageinstaller安装APK时 mHandler = new PackageHandler(mHandlerThread.getLooper()); mProcessLoggingHandler = new ProcessLoggingHandler(); Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT); // 创建各种目录 File dataDir = Environment.getDataDirectory(); mAppInstallDir = new File(dataDir, "app"); mAppLib32InstallDir = new File(dataDir, "app-lib"); mEphemeralInstallDir = new File(dataDir, "app-ephemeral"); mAsecInternalPath = new File(dataDir, "app-asec").getPath(); mDrmAppPrivateInstallDir = new File(dataDir, "app-private"); // 创建用户管理服务 sUserManager = new UserManagerService(context, this, mPackages); // Propagate permission configuration in to package manager. ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions(); for (int i=0; i&lt;permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); if (bp == null) &#123; bp = new BasePermission(perm.name, "android", BasePermission.TYPE_BUILTIN); mSettings.mPermissions.put(perm.name, bp); &#125; if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125; &#125; // 获取共享库 ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries(); for (int i=0; i&lt;libConfig.size(); i++) &#123; mSharedLibraries.put(libConfig.keyAt(i), new SharedLibraryEntry(libConfig.valueAt(i), null)); &#125; mFoundPolicyFile = SELinuxMMAC.readInstallPolicy(); // 解析packages.xml和packages-backup.xml mRestoredSettings = mSettings.readLPw(sUserManager.getUsers(false)); ... &#125; 我们再来总结PMS_START阶段都做了什么： 总结阶段一主要工作如下： 构造DisplayMetrics类：描述界面显示，尺寸，分辨率，密度。构造完后并获取默认的信息保存到变量mMetrics中。 构造Settings类：这个是Android的全局管理者，用于协助PMS保存所有的安装包信息 保存Installer对象 获取系统配置信息：SystemConfig构造函数中会通过readPermissions()解析指定目录下的所有xml文件,然后把这些信息保存到systemConfig中，涉及的目录有如下： /system/etc/sysconfig /system/etc/permissions /oem/etc/sysconfig /oem/etc/permissions 创建名为PackageManager的handler线程，建立PackageHandler消息循环，用于处理外部的安装请求等消息 创建data下的各种目录，比如data/app, data/app-private等。 创建用户管理服务UserManagerService 把systemConfig关于xml中的标签所指的动态库保存到mSharedLibraries Settings.readLPw扫描解析packages.xml和packages-backup.xml 补充说明下debug.separate_processes这个属性：这个属性你可以使用强制应用程序组件在自己的进程中运行，有两种方法可以使用这个： 1234// 所有的进程都会受到影响setprop debug.separate_processes // 指定进程受影响setprop debug.separate_processes“com.google.process.content, com.google.android.samples” 这个属性一般不会用到。 PMS_SYSTEM_SCAN_START接下来是BOOT_PROGRESS_PMS_SYSTEM_SCAN_START阶段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178long startTime = SystemClock.uptimeMillis();EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;//该集合中存放的是已经优化或者不需要优先的文件final ArraySet&lt;String&gt; alreadyDexOpted = new ArraySet&lt;String&gt;();final String bootClassPath = System.getenv("BOOTCLASSPATH");final String systemServerClassPath = System.getenv("SYSTEMSERVERCLASSPATH");//将环境变量BOOTCLASSPATH所执行的文件加入alreadyDexOptedif (bootClassPath != null) &#123; String[] bootClassPathElements = splitString(bootClassPath, ':'); for (String element : bootClassPathElements) &#123; alreadyDexOpted.add(element); &#125;&#125;//将环境变量SYSTEMSERVERCLASSPATH所执行的文件加入alreadyDexOptedif (systemServerClassPath != null) &#123; String[] systemServerClassPathElements = splitString(systemServerClassPath, ':'); for (String element : systemServerClassPathElements) &#123; alreadyDexOpted.add(element); &#125;&#125;...//此处共享库是由SystemConfig实例化过程赋值的if (mSharedLibraries.size() &gt; 0) &#123; for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123; final String lib = libEntry.path; ... int dexoptNeeded = DexFile.getDexOptNeeded(lib, dexCodeInstructionSet, "speed", false); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; alreadyDexOpted.add(lib); //执行dexopt操作 mInstaller.dexopt(lib, Process.SYSTEM_UID, dexCodeInstructionSet, dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/); &#125; &#125; &#125;&#125;//此处frameworkDir目录为/system/frameworkFile frameworkDir = new File(Environment.getRootDirectory(), "framework");//添加以下两个文件添加到已优化集合alreadyDexOpted.add(frameworkDir.getPath() + "/framework-res.apk");alreadyDexOpted.add(frameworkDir.getPath() + "/core-libart.jar");String[] frameworkFiles = frameworkDir.list();if (frameworkFiles != null) &#123; for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (int i=0; i&lt;frameworkFiles.length; i++) &#123; File libPath = new File(frameworkDir, frameworkFiles[i]); String path = libPath.getPath(); //跳过已优化集合中的文件 if (alreadyDexOpted.contains(path)) &#123; continue; &#125; //跳过后缀不为apk和jar的文件 if (!path.endsWith(".apk") &amp;&amp; !path.endsWith(".jar")) &#123; continue; &#125; int dexoptNeeded = DexFile.getDexOptNeeded(path, dexCodeInstructionSet, "speed", false); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; //执行dexopt操作【见小节2.2.1】 mInstaller.dexopt(path, Process.SYSTEM_UID, dexCodeInstructionSet, dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/); &#125; &#125; &#125;&#125;final VersionInfo ver = mSettings.getInternalVersion();mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);mPromoteSystemApps = mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;if (mPromoteSystemApps) &#123; Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator(); while (pkgSettingIter.hasNext()) &#123; PackageSetting ps = pkgSettingIter.next(); if (isSystemApp(ps)) &#123; mExistingSystemPackages.add(ps.name); &#125; &#125;&#125;//收集供应商包名：/vendor/overlayFile vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);//收集包名：/system/frameworkscanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0);//收集私有的系统包名：/system/priv-appfinal File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);//收集一般地系统包名：/system/appfinal File systemAppDir = new File(Environment.getRootDirectory(), "app");scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//收集私有供应商包名：/vendor/priv-appfinal File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), "priv-app");scanDirLI(privilegedVendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);//收集所有的供应商包名：/vendor/appFile vendorAppDir = new File(Environment.getVendorDirectory(), "app");vendorAppDir = vendorAppDir.getCanonicalFile();scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//收集所有OEM包名：/oem/appfinal File oemAppDir = new File(Environment.getOemDirectory(), "app");scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//移除文件mInstaller.moveFiles();//删除不在存在的系统包final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();if (!mOnlyCore) &#123; Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator(); while (psit.hasNext()) &#123; PackageSetting ps = psit.next(); if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; continue; &#125; final PackageParser.Package scannedPkg = mPackages.get(ps.name); if (scannedPkg != null) &#123; if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; removePackageLI(ps, true); mExpectingBetter.put(ps.name, ps.codePath); &#125; continue; &#125; if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; psit.remove(); removeDataDirsLI(null, ps.name); &#125; else &#123; final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name); if (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123; possiblyDeletedUpdatedSystemApps.add(ps.name); &#125; &#125; &#125;&#125;//清理所有安装不完整的包ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();for(int i = 0; i &lt; deletePkgsList.size(); i++) &#123; cleanupInstallFailedPackage(deletePkgsList.get(i));&#125;//删除临时文件deleteTempPackageFiles();//移除不相干包中的所有共享userIDmSettings.pruneSharedUsersLPw(); PMS_SYSTEM_SCAN_START阶段主要做了如下工作： 首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化集合alreadyDexOpted中 SYSTEMSERVERCLASSPATH：主要包括/system/framework目录下services.jar，ethernet-service.jar，wifi-service.jar这3个文件。 BOOTCLASSPATH：该环境变量内容较多，不同ROM可能有所不同，常见内容包含/system/framework目录下的framework.jar，ext.jar，core-libart.jar，telephony-common.jar，ims-common.jar，core-junit.jar等文件。 获取共享库mSharedLibraries，判断是否需要dex优化，如果需要则进行dex优化，并加入到alreadyDexOpted列表中 添加framework-res.apk、core-libart.jar两个文件添加到已优化集合alreadyDexOpted中 将framework目录下，其他的apk或者jar，进行dex优化并加入已优化集合alreadyDexOpted中 scanDirLI(): 扫描指定目录下的apk文件，最终调用PackageParser.parseBaseApk来完成AndroidManifest.xml文件的解析，生成Application, activity,service,broadcast, provider等信息 删除系统不存在的包 removePackageLI 清理安装失败的包 cleanupInstallFailedPackage 删除临时文件 deleteTempPackageFiles 移除不相干包中的所有共享userID PMS_DATA_SCAN_STARTBOOT_PROGRESS_PMS_DATA_SCAN_START阶段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283if (!mOnlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis()); scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK, scanFlags | SCAN_REQUIRE_KNOWN, 0); /** * Remove disable package settings for any updated system * apps that were removed via an OTA. If they're not a * previously-updated app, remove them completely. * Otherwise, just revoke their system-level permissions. */ for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123; PackageParser.Package deletedPkg = mPackages.get(deletedAppName); mSettings.removeDisabledSystemPackageLPw(deletedAppName); String msg; if (deletedPkg == null) &#123; msg = "Updated system package " + deletedAppName + " no longer exists; wiping its data"; removeDataDirsLI(null, deletedAppName); &#125; else &#123; msg = "Updated system app + " + deletedAppName + " no longer present; removing system privileges for " + deletedAppName; deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM; PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName); deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM; &#125; logCriticalInfo(Log.WARN, msg); &#125; /** * Make sure all system apps that we expected to appear on * the userdata partition actually showed up. If they never * appeared, crawl back and revive the system version. */ for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123; final String packageName = mExpectingBetter.keyAt(i); if (!mPackages.containsKey(packageName)) &#123; final File scanFile = mExpectingBetter.valueAt(i); logCriticalInfo(Log.WARN, "Expected better " + packageName + " but never showed up; reverting to system"); final int reparseFlags; if (FileUtils.contains(privilegedAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED; &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(vendorAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else &#123; Slog.e(TAG, "Ignoring unexpected fallback path " + scanFile); continue; &#125; mSettings.enableSystemPackageLPw(packageName); try &#123; scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, "Failed to parse original system package: " + e.getMessage()); &#125; &#125; &#125; &#125; mExpectingBetter.clear(); // Now that we know all of the shared libraries, update all clients to have // the correct library paths. updateAllSharedLibrariesLPw(); for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123; // NOTE: We ignore potential failures here during a system scan (like // the rest of the commands above) because there's precious little we // can do about it. A settings error is reported, though. adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */, false /* force dexopt */, false /* defer dexopt */); &#125; // Now that we know all the packages we are keeping, // read and update their last usage times. mPackageUsage.readLP(); 当mOnlyCore = false时，则scanDirLI()还会收集如下目录中的apk /data/app /data/app-private PMS_SCAN_ENDBOOT_PROGRESS_PMS_SCAN_END阶段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());Slog.i(TAG, "Time to scan packages: " + ((SystemClock.uptimeMillis()-startTime)/1000f) + " seconds");// 当sdk版本不一致时，需要更新权限int updateFlags = UPDATE_PERMISSIONS_ALL;if (ver.sdkVersion != mSdkVersion) &#123; Slog.i(TAG, "Platform changed from " + ver.sdkVersion + " to " + mSdkVersion + "; regranting permissions for internal storage"); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;&#125;updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);ver.sdkVersion = mSdkVersion;//当这是ota后的首次启动，正常启动则需要清除目录的缓存代码if (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123; for (UserInfo user : sUserManager.getUsers(true)) &#123; mSettings.applyDefaultPreferredAppsLPw(this, user.id); applyFactoryDefaultBrowserLPw(user.id); primeDomainVerificationsLPw(user.id); &#125;&#125;//当权限和其他默认项都完成更新，则清理相关信息final int storageFlags;if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123; storageFlags = StorageManager.FLAG_STORAGE_DE;&#125; else &#123; storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;&#125;reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM, storageFlags);//当这是ota后的首次启动，正常启动则需要清除目录的缓存代码if (mIsUpgrade &amp;&amp; !onlyCore) &#123; Slog.i(TAG, "Build fingerprint changed; clearing code caches"); for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123; final PackageSetting ps = mSettings.mPackages.valueAt(i); if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123; // No apps are running this early, so no need to freeze clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); &#125; &#125; ver.fingerprint = Build.FINGERPRINT;&#125;checkDefaultBrowser();//当权限和其他默认项都完成更新，则清理相关信息mExistingSystemPackages.clear();mPromoteSystemApps = false;// All the changes are done during package scanning.ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;//信息写回packages.xml文件mSettings.writeLPr(); 当sdk版本不一致时，需要更新权限 当这是ota后的首次启动，正常启动则需要清除目录的缓存代码 当权限和其他默认项都完成更新，则清理相关信息 信息写回packages.xml文件 PMS_READYBOOT_PROGRESS_PMS_READY阶段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis()); if (!mOnlyCore) &#123; mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr(); mRequiredInstallerPackage = getRequiredInstallerLPr(); mRequiredUninstallerPackage = getRequiredUninstallerLPr(); mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr(); mIntentFilterVerifier = new IntentVerifierProxy(mContext, mIntentFilterVerifierComponent); mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES); mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SHARED); &#125; else &#123; mRequiredVerifierPackage = null; mRequiredInstallerPackage = null; mRequiredUninstallerPackage = null; mIntentFilterVerifierComponent = null; mIntentFilterVerifier = null; mServicesSystemSharedLibraryPackageName = null; mSharedSystemSharedLibraryPackageName = null; &#125; mInstallerService = new PackageInstallerService(context, this); final ComponentName ephemeralResolverComponent = getEphemeralResolverLPr(); final ComponentName ephemeralInstallerComponent = getEphemeralInstallerLPr(); // both the installer and resolver must be present to enable ephemeral if (ephemeralInstallerComponent != null &amp;&amp; ephemeralResolverComponent != null) &#123; if (DEBUG_EPHEMERAL) &#123; Slog.i(TAG, "Ephemeral activated; resolver: " + ephemeralResolverComponent + " installer:" + ephemeralInstallerComponent); &#125; mEphemeralResolverComponent = ephemeralResolverComponent; mEphemeralInstallerComponent = ephemeralInstallerComponent; setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent); mEphemeralResolverConnection = new EphemeralResolverConnection(mContext, mEphemeralResolverComponent); &#125; else &#123; if (DEBUG_EPHEMERAL) &#123; final String missingComponent = (ephemeralResolverComponent == null) ? (ephemeralInstallerComponent == null) ? "resolver and installer" : "resolver" : "installer"; Slog.i(TAG, "Ephemeral deactivated; missing " + missingComponent); &#125; mEphemeralResolverComponent = null; mEphemeralInstallerComponent = null; mEphemeralResolverConnection = null; &#125; mEphemeralApplicationRegistry = new EphemeralApplicationRegistry(this);&#125; // synchronized (mPackages)&#125; // synchronized (mInstallLock)// Now after opening every single application zip, make sure they// are all flushed. Not really needed, but keeps things nice and// tidy.Runtime.getRuntime().gc();// The initial scanning above does many calls into installd while// holding the mPackages lock, but we're mostly interested in yelling// once we have a booted system.mInstaller.setWarnIfHeld(mPackages);// Expose private service for system components to use.LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl()); 初始化PackageInstallerService GC回收下内存 PMS构造函数 - 总结PMS初始化过程，分为5个阶段： 1. PMS_START阶段： 创建Settings对象； 将6类shareUserId到mSettings； 初始化SystemConfig； 创建名为“PackageManager”的handler线程mHandlerThread; 创建UserManagerService多用户管理服务； 通过解析4大目录中的xmL文件构造共享mSharedLibraries； 2. PMS_SYSTEM_SCAN_START阶段： mSharedLibraries共享库中的文件执行dexopt操作； system/framework目录中满足条件的apk或jar文件执行dexopt操作； 扫描系统apk; 3. PMS_DATA_SCAN_START阶段： 扫描/data/app目录下的apk; 扫描/data/app-private目录下的apk; 4. PMS_SCAN_END阶段： 将上述信息写回/data/system/packages.xml; 5. PMS_READY阶段： 创建服务PackageInstallerService； 到这里，大致介绍完了整个PMS构造函数的流程，基本上PMS_SCAN_END阶段我们apk就算安装完成了，那么接下来我们单独看看其中几个比较重要的模块： Settings SystemConfig - readPermissions scanPackageLI Settings在BOOT_PROGRESS_PMS_START阶段，我们会创建Setting对象，以及一堆的addSharedUserLPw调用：123mSettings = new Settings(mPackages);mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); 创建Settings frameworks/base/services/core/java/com/android/server/pm/Settings.java 123456789101112131415161718192021222324252627282930313233343536Settings(Object lock) &#123; this(Environment.getDataDirectory(), lock);&#125;Settings(File dataDir, Object lock) &#123; mLock = lock; mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock); //创建目录"data/system" mSystemDir = new File(dataDir, "system"); mSystemDir.mkdirs(); FileUtils.setPermissions(mSystemDir.toString(), FileUtils.S_IRWXU|FileUtils.S_IRWXG |FileUtils.S_IROTH|FileUtils.S_IXOTH, -1, -1); // packages.xml和packages-backup.xml为一组，用于描述系统所安装的Package信息， // 其中packages-backup.xml是packages.xml的备份 // PMS写把数据写到backup文件中，信息全部写成功后在改名为非backup文件， // 以防止在写文件的过程中出错，导致信息丢失 mSettingsFilename = new File(mSystemDir, "packages.xml"); mBackupSettingsFilename = new File(mSystemDir, "packages-backup.xml"); //packages.list保存系统中存在的所有非系统自带的APK信息，即UID大于10000的apk mPackageListFilename = new File(mSystemDir, "packages.list"); FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID); //感觉是sdcardfs相关的文件 final File kernelDir = new File("/config/sdcardfs"); mKernelMappingFilename = kernelDir.exists() ? kernelDir : null; // Deprecated: Needed for migration //packages-stopped.xml用于描述系统中强行停止运行的package信息，backup也是备份文件 mStoppedPackagesFilename = new File(mSystemDir, "packages-stopped.xml"); mBackupStoppedPackagesFilename = new File(mSystemDir, "packages-stopped-backup.xml");&#125; Settings的构造函数主要用于创建”data/system”目录和一些xml文件，并配置相应的权限,其中： packages.xml 记录所有安装app的信息，当系统进行程序安装、卸载和更新等操作时，均会更新该文件。 packages-backup.xml 备份文件 packages-stopped.xml 记录被用户强行停止的应用的Package信息 packages-stopped-backup.xml 备份文件 packages.list 记录非系统自带的APK的数据信息，这些APK有变化时会更新该文件 Setings.readLPwreadLPw()函数，从/data/system/packages.xml或packages-backup.xml文件中获得packages、permissions相关信息，添加到相关内存列表中。packages.xml文件记录了系统的permisssions以及每个APK的name、codePath、flags、version等信息这些信息主要通过APK的AndroidManifest.xml解析获取，解析完APK后将更新信息写入这个文件，下次开机直接从里面读取相关信息添加到内存相关结构中。当有APK升级、安装或删除时会更新这个文件。 Settings.writeLPrwriteLPr函数，将解析出的每个APK的信息（mSetting.mPackages）保存到packages.xml和packages.list文件。packages.list记录了如下数据：pkgName, userId, debugFlag, dataPath(包的数据路径)。 SystemConfig - readPermissions同样是在BOOT_PROGRESS_PMS_START阶段，我们会初始化SystemConfig去获取系统配置信息： 12345// 获取系统配置信息SystemConfig systemConfig = SystemConfig.getInstance();mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions();mAvailableFeatures = systemConfig.getAvailableFeatures(); 创建SystemConfig frameworks/base/services/core/java/com/android/server/SystemConfig.java 1234567891011121314151617181920212223242526272829303132//单例模式public static SystemConfig getInstance() &#123; synchronized (SystemConfig.class) &#123; if (sInstance == null) &#123; sInstance = new SystemConfig(); &#125; return sInstance; &#125;&#125;SystemConfig() &#123; // system/etc/目录 readPermissions(Environment.buildPath( Environment.getRootDirectory(), "etc", "sysconfig"), ALLOW_ALL); readPermissions(Environment.buildPath( Environment.getRootDirectory(), "etc", "permissions"), ALLOW_ALL); int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS; // odm/etc/目录 readPermissions(Environment.buildPath( Environment.getOdmDirectory(), "etc", "sysconfig"), odmPermissionFlag); readPermissions(Environment.buildPath( Environment.getOdmDirectory(), "etc", "permissions"), odmPermissionFlag); // oem/etc/目录 readPermissions(Environment.buildPath( Environment.getOemDirectory(), "etc", "sysconfig"), ALLOW_FEATURES); readPermissions(Environment.buildPath( Environment.getOemDirectory(), "etc", "permissions"), ALLOW_FEATURES);&#125; 从上面的代码可以看出，SystemConfig是单例模式，会通过readPermissions解析指定目录下的xml文件： /system/etc/sysconfig /system/etc/permissions /odm/etc/sysconfig /odm/etc/permissions /oem/etc/sysconfig /oem/etc/permissions 其中比较重要的是system/etc/permissions目录，该目录文件大多来源于代码中的framworks/(base or native)/data/etc，这些文件的作用是表明系统支持的feature有哪些，例如是否支持蓝牙、wifi、P2P等。 readPermissionsreadPermissions会循环去读取目录下的xml文件，但是它会跳过platform.xml文件，最后再去读取platform.xml文件。 12345678910111213141516171819202122void readPermissions(File libraryDir, int permissionFlag) &#123; //检测目录是否存在，是否可读 .......... // Iterate over the files in the directory and scan .xml files File platformFile = null; // 循环解析xml文件 for (File f : libraryDir.listFiles()) &#123; // 跳过，最后再解析platform.xml if (f.getPath().endsWith("etc/permissions/platform.xml")) &#123; platformFile = f; continue; &#125; // 解析可读的xml文件 readPermissionsFromXml(f, permissionFlag); &#125; // 最后解析platform.xml文件 if (platformFile != null) &#123; readPermissionsFromXml(platformFile, permissionFlag); &#125;&#125; 我们发现读取函数最后都调用了readPermissionsFromXml()，函数readPermissionsFromXml最终会使用XMLPullParser的方式解析这些XML文件，然后把解析出来的数据结构保存到PMS中。 android.hardware.bluetooth.xml最终会解析并且保存到PMS的final ArrayMap&lt;String, FeatureInfo&gt; mAvailableFeatures中。 123&lt;permissions&gt; &lt;feature name="android.hardware.bluetooth" /&gt; &lt;/permissions&gt; com.android.location.provider.xml指明了运行一些library时，还需要加载一些java库。这个最终会解析并保存到PMS的final ArrayMap&lt;String, SharedLibraryEntry&gt; mSharedLibraries中。 1234&lt;permissions&gt; &lt;library name="com.android.location.provider" file="/system/framework/com.android.location.provider.jar" /&gt;&lt;/permissions&gt; platform.xml这个文件中定义了底层GID和app层权限名字之间的对应关系，或者直接给某一个uid赋予对应的权限： 123456789101112&lt;permissions&gt; &lt;permission name="android.permission.WRITE_EXTERNAL_STORAGE" &gt; &lt;group gid="sdcard_r" /&gt; &lt;group gid="sdcard_rw" /&gt; &lt;/permission&gt; ...... &lt;assign-permission name="android.permission.MODIFY_AUDIO_SETTINGS" uid="media" /&gt; &lt;assign-permission name="android.permission.ACCESS_SURFACE_FLINGER" uid="media" /&gt; ......&lt;/permissions&gt; 解析&lt;permission&gt;标签的时候，会创建一个PermissionEntry类，他关联了gids和permission name：最终PermissionEntry会放入SystemConfig的final ArrayMap&lt;String, PermissionEntry&gt; mPermissions变量中。 1234567public static final class PermissionEntry &#123; public final String name; public int[] gids; PermissionEntry(String _name) &#123; name = _name; &#125; &#125; 解析&lt;assign-permission&gt;的时候表示把属性name中的字符串表示的权限赋予属性uid中的用户。uid和name则存入SystemConfig中的SparseArray&gt; 类型的mSystemPermissions变量中。 scanPackageLIscanPackageLI是比较重要的安装apk的方法，下面具体分析。 scanDirLIscanDirLI函数会处理目录下每一个package文件：(当然不止scanDirLI最后会调用到scanPackageLI) 1234567891011121314151617181920private void scanDirLI(File dir, final int parseFlags, int scanFlags, long currentTime) &#123; final File[] files = dir.listFiles(); ....... for (File file : files) &#123; final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) &#123; // Ignore entries which are not packages continue; &#125; try &#123; //处理目录下每一个package文件 scanPackageTracedLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null); &#125; catch (PackageManagerException e) &#123; ......... &#125; &#125;&#125; scanPackageTracedLI函数最终会调用到scanPackageLI函数： 123456789private PackageParser.Package scanPackageTracedLI(File scanFile, final int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "scanPackage"); try &#123; return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; scanPackageLI安装apkPackageManagerService的scanPackageLI过程scanPackageLI()有3个重载的方法，参数稍有不同： 123456789// 第（1）个private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user)// 第（2）个private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile, final int policyFlags, int scanFlags, long currentTime, UserHandle user)// 第（3）个private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, UserHandle user) （1）scanPackageLI(File scanFile, int parseFlags,…）函数 实例化一个PackageParser对象，接着调用该对象的parsePackage()对APK文件进行解析。 实例化一个Package对象，用于保存解析出的APK信息 从AndroidManifest.xml文件中解析出VersionCode、VersionName、installLocation等全局属性信息，然后根据标签循环解析XML文件包含的其它组成部分，将解析出的信息添加到Package对象的相关列表中。 123456789101112131415161718private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; //创建出PackageParser对象 PackageParser pp = new PackageParser(); ........... final PackageParser.Package pkg; try &#123; // 解析package pkg = pp.parsePackage(scanFile, parseFlags); &#125; catch (PackageParserException e) &#123; .......... &#125; finally &#123; .......... &#125; //调用第（2）个scanPackageLI return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);&#125; 最后会调用第（2）个scanPackageLI去继续解析。 （2）scanPackageLI(PackageParser.Package pkg, File scanFile,…)函数 123456789101112131415161718192021222324252627282930313233343536373839private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; //有childPackage时，第一次只执行检查的工作 if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; //当解析一个Package的AndroidManifest.xml时，如果该XML文件中使用了"package"的tag //那么该tag对应的package是当前XML文件对应package的childPackage if (pkg.childPackages != null &amp;&amp; pkg.childPackages.size() &gt; 0) &#123; scanFlags |= SCAN_CHECK_ONLY; &#125; &#125; else &#123; //第二次进入，才开始实际的解析 scanFlags &amp;= ~SCAN_CHECK_ONLY; &#125; final PackageParser.Package scannedPkg; try &#123; // Scan the parent //scanFlags将决定这一次是否仅执行检查工作 scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags, currentTime, user); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); scanPackageLI(childPkg, policyFlags, scanFlags, currentTime, user); &#125; &#125; finally &#123; ......... &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; //第一次检查完毕后，再次调用函数 return scanPackageTracedLI(pkg, policyFlags, scanFlags, currentTime, user); &#125; return scannedPkg;&#125; （3）scanPackageLI(PackageParser.Package pkg, final int policyFlags,…)函数 最终会走到第三个scanPackageLI函数，这个函数最后会调用scanPackageDirtyLI函数，scanPackageDirtyLI是实际解析package的函数，这个才是真正干活的。 12345678910111213private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; boolean success = false; try &#123; //实际的解析函数，很长... final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags, currentTime, user); success = true; return res; &#125; finally &#123; ........... &#125;&#125; scanPackageDirtyLI通过上述的扫描过程，我们得到了当前apk文件对应的Package信息。不过这部分信息是存储在PackageParser中的，我们必须将这部分信息传递到PMS中。毕竟最终的目的是：让PMS能得到所有目录下Package的信息。scanPackageDirtyLI函数主要就是把签名解析应用程序得到的package、provider、service、receiver和activity等信息保存在PackageManagerService相关的成员列表里。 比如将每个APK的receivers列表里的元素，通过mReceivers.addActivity(a, “receiver”)添加到PMS成员列表mReceivers中: 1final ActivityIntentResolver mReceivers = new ActivityIntentResolver();` 由于实际解析函数太长，粗略看下有1000来行，读者有兴趣的可以自行研究。 http://blog.csdn.net/column/details/13723.html?&amp;page=2 开机时间分析adb shell cat /proc/bootprof/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 C:\Users\shun&gt;adb shell cat /proc/bootprof----------------------------------------0 BOOT PROF (unit:msec)---------------------------------------- 1655 : preloader 1001 : lk 493 : lk-&gt;Kernel---------------------------------------- 5156.702307 : Kernel_init_done 5171.629538 : SElinux start. 10739.699692 : SElinux end. 11496.788538 : INIT: on init start 11878.325615 : INIT:eMMC:Mount_START 12777.653384 : INIT:eMMC:Mount_END 12780.874230 : INIT:PROTECT:Mount_START 12938.042615 : INIT:PROTECT:Mount_END 14029.370538 : INIT: eng build setting 15215.342538 : BOOT_Animation:START 16618.475076 : Zygote:Preload Start 20691.658230 : Zygote:Preload 2775 classes in 4062ms 23061.424153 : Zygote:Preload 274 obtain resources in 2334ms 23110.519076 : Zygote:Preload 31 resources in 47ms 23240.816000 : Zygote:Preload End 23720.832000 : Android:SysServerInit_START 24448.175153 : Android:PackageManagerService_Start 24747.363153 : Android:PMS_scan_START 24817.216000 : Android:PMS_scan_done:/custom/framework 24947.104384 : Android:PMS_scan_done:/system/framework 25131.265384 : Android:PMS_scan_done:/system/priv-app 25533.440461 : Android:PMS_scan_done:/system/app 25540.237769 : Android:PMS_scan_done:/system/vendor/app 25542.379538 : Android:PMS_scan_done:/system/vendor/operator/app 25544.285615 : Android:PMS_scan_done:/custom/app 25551.297076 : Android:PMS_scan_data_start 25967.971076 : Android:PMS_scan_data_done:/data/app 25969.811230 : Android:PMS_scan_data_done:/data/app-private 25971.862692 : Android:PMS_scan_END 26224.410076 : Android:PMS_READY 30108.635538 : AP_Init:[service]:[com.mediatek.security]:[com.mediatek.security/.service.PermControlService]:pid:738 30548.305692 : AP_Init:[broadcast]:[com.android.settings]:[com.android.settings/.widget.SettingsAppWidgetProvider]:pid:769 31341.380923 : AP_Init:[broadcast]:[com.mediatek.engineermode]:[com.mediatek.engineermode/.wifi.WifiStateReceiver]:pid:806 31563.917923 : AP_Init:[broadcast]:[com.tvguo.app]:[com.tvguo.app/.content.TvguoStateReceiver]:pid:829 31708.206000 : AP_Init:[service]:[com.android.systemui]:[com.android.systemui/.ImageWallpaper]:pid:847 31796.008076 : AP_Init:[service]:[com.android.inputmethod.latin]:[com.android.inputmethod.latin/.LatinIME]:pid:860 31987.434923 : AP_Init:[added application]:[com.mediatek.dongle]:[com.mediatek.dongle]:pid:878:(PersistAP) 32051.271692 : AP_Init:[added application]:[com.mediatek.bluetooth]:[com.mediatek.bluetooth]:pid:891:(PersistAP) 32142.389846 : AP_Init:[activity]:[com.android.launcher3]:[com.android.launcher3/.Launcher]:pid:906 32170.530846 : Android:SysServerInit_END 32309.788000 : AP_Init:[service]:[com.android.printspooler]:[com.android.printspooler/.PrintSpoolerService]:pid:923 33967.604076 : AP_Init:[broadcast]:[com.android.contacts]:[com.android.contacts/com.mediatek.contacts.simcontact.BootCmpReceiver]:pid:972 34752.970538 : AP_Init:[content provider]:[android.process.acore]:[com.android.providers.contacts/.ContactsProvider2]:pid:1028 35486.120000 : BOOT_Animation:END--------------------------------- 我们可以从上面的信息看到PMS在开机的时候做的动作和时间分布：（因为手上只有kk的平台，所以信息不太对应） 1234567891011121324747.363153 : Android:PMS_scan_START24817.216000 : Android:PMS_scan_done:/custom/framework24947.104384 : Android:PMS_scan_done:/system/framework25131.265384 : Android:PMS_scan_done:/system/priv-app25533.440461 : Android:PMS_scan_done:/system/app25540.237769 : Android:PMS_scan_done:/system/vendor/app25542.379538 : Android:PMS_scan_done:/system/vendor/operator/app25544.285615 : Android:PMS_scan_done:/custom/app25551.297076 : Android:PMS_scan_data_start25967.971076 : Android:PMS_scan_data_done:/data/app25969.811230 : Android:PMS_scan_data_done:/data/app-private25971.862692 : Android:PMS_scan_END26224.410076 : Android:PMS_READY 一般app装的越多，那么开机时间就会越长。 附录 packages.xml 文件 packages.list 文件 platform.xml 文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android系统启动流程]]></title>
      <url>%2F2017%2F01%2F06%2Fandroid-start%2F</url>
      <content type="text"><![CDATA[本文介绍android的启动流程。 系统启动架构图： 1 Loader层1. Boot ROM: 上电后，BootRom会被激活，引导芯片代码开始从预定义的地方（固化在ROM）开始执行，然后加载引导程序到RAM。 2. Boot Loader引导程序Boot Loader是启动Android系统之前的引导程序，引导程序是OEM厂商或者运营商加锁和限制的地方，它是针对特定的主板与芯片的。OEM厂商要么使用很受欢迎的引导程序比如redboot、uboot、ARMboot等或者开发自己的引导程序，它不是Android操作系统的一部分。Boot Loader主要作用是检查RAM，初始化硬件参数等功能。 3 Preloader: （1）Preloader是MTK平台独有的防止芯片被Hack的一个loader，MTK平台的bootrom会先加载preloader到SRAM中，preloader会先去初始化一些HW组件，比如通信端口(USB/Uart)，外部存储设备(Emmc or Nand)，内存设备(DRAM Calibration)等，最后会Load LK到DRAM中并且run LK(U-boot)。（2）LK会从外部存储设备load boot image,包括Linux kernel和Ramdisk到DRAM中.最后LK会跳到 Linux Kernel里去执行start kernel.（3）linux kernel会先完成一些初始化动作，mount 根文件系统和启动第一个用户进程(init 进程) 2 kernel层Android内核与linux内核启动的方式差不多。Kernel的启动流程： alps/kernel/init/main.cstart_kernel() ==&gt; rest_init() ==&gt; kernel_thread(kernel_init) ==&gt; kernel_init() 2.1 rest_init()1234567891011static noinline void __ref rest_init(void)&#123; ... kernel_thread(kernel_init, NULL, CLONE_FS); pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); ... init_idle_bootup_task(current); schedule_preempt_disabled(); ... cpu_idle();&#125; rest_init中调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd 调用schedule函数开启了内核的调度系统，从此linux系统开始转起来了。 rest_init最终调用cpu_idle函数结束了整个内核的启动。也就是说linux内核最终结束了一个函数cpu_idle。这个函数里面肯定是死循环。 简单来说，linux内核最终的状态是：有事干的时候去执行有意义的工作（执行各个进程任务），实在没活干的时候就去死循环（实际上死循环也可以看成是一个任务）。 之前已经启动了内核调度系统，调度系统会负责考评系统中所有的进程，这些进程里面只有有哪个需要被运行，调度系统就会终止cpu_idle死循环进程（空闲进程）转而去执行有意义的干活的进程。这样操作系统就转起来了。 0号进程：swapper进程(pid=0)：又称为idle进程, 叫空闲进程，由系统自动创建, 运行在内核态。系统初始化过程Kernel由无到有开创的第一个进程, 也是唯一一个没有通过fork或者kernel_thread产生的进程。swapper进程用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作。 1号进程 init进程(pid=1)：由0号进程通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 并最终运行在用户空间，init进程是所有用户进程的鼻祖。 2号进程 kthreadd进程(pid=2)：由0号进程通过kernel_thread创建，是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd运行在内核空间, 负责所有内核线程的调度和管理 , kthreadd进程是所有内核进程的鼻祖。 2.2 kernel_init()init进程会通过kernel_init创建，这个时候是在内核态，那么怎么一步步走到用户态呢？ kernel_init-&gt;init_post-&gt;run_init_process-&gt;kernel_execve 12345678910111213141516171819static int __init kernel_init(void * unused) &#123; /*Wait until kthreadd is all set-up.*/ wait_for_completion(&amp;kthreadd_done); //主要是初始化设备驱动，完成其他驱动程序（直接编译进内核的模块）的初始化。 do_basic_setup(); //挂载根文件系统 if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) &lt; 0) printk(KERN_WARNING "Warning: unable to open an initial console.\n"); //定义init进程 if (!ramdisk_execute_command) ramdisk_execute_command = "/init"; //最后调用init_post，启动进程负责用户空间的初始化 init_post(); &#125; 接下来定位到init_post的函数体，代码如下： 123456789101112131415static noinline int init_post(void) &#123; ……//省略部分代码 if (ramdisk_execute_command) &#123; //run_init_process执行后将不再返回 run_init_process(ramdisk_execute_command); &#125; if (execute_command) &#123; run_init_process(execute_command); &#125; run_init_process("/sbin/init"); run_init_process("/etc/init"); run_init_process("/bin/init"); run_init_process("/bin/sh"); &#125; execute_command 是bootloader传递给内核的参数，一般是/init（即根目录下的init程序），也就是调用文件系统里的init进程。如果找不到就会继续寻找“/sbin/init”、“/etc/init”、“/bin/init”、“/bin/sh”，找到后便执行run_init_process，且不再返回。run_init_process的函数体非常简单，仅仅是对kernel_execve函数的封装，代码如下： 12345static void run_init_process(const char *init_filename) &#123; argv_init[0] = init_filename; kernel_execve(init_filename, argv_init, envp_init); &#125; kernel_execve是Linux内核中创建用户进程的方法接口，其实现位于 arch/arm/kernel/sys_arm.c。 那么至此，我们已经对Android Kernel如何引导以及用户空间1号进程（init进程）如何启动做了详细分析。 3 Init进程3.1 Init Process这里的Native层主要说明init进程，当kernel Initialize完成之后，系统会执行第一个用户进程init，我们可以说它是root进程或者所有进程的父进程。init进程相关的代码： /system/core/init/init.cpp：/system/core/rootdir/init.rc/system/core/init/readme.txt Init进程启动过程就是代码init.cpp中main函数执行过程，我们来看看它做了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174int main(int argc, char** argv) &#123; if (!strcmp(basename(argv[0]), "ueventd")) &#123; return ueventd_main(argc, argv); &#125; if (!strcmp(basename(argv[0]), "watchdogd")) &#123; return watchdogd_main(argc, argv); &#125; // Clear the umask. umask(0); add_environment("PATH", _PATH_DEFPATH); bool is_first_stage = (argc == 1) || (strcmp(argv[1], "--second-stage") != 0); //挂载tmpfs, devpts, proc, sysfs文件系统 if (is_first_stage) &#123; mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"); mkdir("/dev/pts", 0755); mkdir("/dev/socket", 0755); mount("devpts", "/dev/pts", "devpts", 0, NULL); #define MAKE_STR(x) __STRING(x) mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC)); mount("sysfs", "/sys", "sysfs", 0, NULL); &#125; // We must have some place other than / to create the device nodes for // kmsg and null, otherwise we won't be able to remount / read-only // later on. Now that tmpfs is mounted on /dev, we can actually talk // to the outside world. //屏蔽标准的输入输出，即标准的输入输出定向到NULL设备。 open_devnull_stdio(); //kernel log初始化 klog_init(); klog_set_level(KLOG_NOTICE_LEVEL); NOTICE("init %s started!\n", is_first_stage ? "first stage" : "second stage"); if (!is_first_stage) &#123; // Indicate that booting is in progress to background fw loaders, etc. close(open("/dev/.booting", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); //创建一块共享的内存空间，用于属性服务 property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. //设置基本属性 process_kernel_dt(); process_kernel_cmdline(); // Propagate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props(); &#125; // Set up SELinux, including loading the SELinux policy if we're in the kernel domain. // 加载SELinux selinux_initialize(is_first_stage); // If we're in the kernel domain, re-exec init to transition to the init domain now // that the SELinux policy has been loaded. if (is_first_stage) &#123; if (restorecon("/init") == -1) &#123; ERROR("restorecon failed: %s\n", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;("--second-stage"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR("execv(\"%s\") failed: %s\n", path, strerror(errno)); security_failure(); &#125; &#125; // These directories were necessarily created before initial policy load // and therefore need their security context restored to the proper value. // This must happen before /dev is populated by ueventd. NOTICE("Running restorecon...\n"); restorecon("/dev"); restorecon("/dev/socket"); restorecon("/dev/__properties__"); restorecon("/property_contexts"); restorecon_recursive("/sys"); epoll_fd = epoll_create1(EPOLL_CLOEXEC); if (epoll_fd == -1) &#123; ERROR("epoll_create1 failed: %s\n", strerror(errno)); exit(1); &#125; //初始化子进程退出的信号处理过程 signal_handler_init(); //加载/default.prop文件 property_load_boot_defaults(); export_oem_lock_status(); //启动属性服务 start_property_service(); const BuiltinFunctionMap function_map; Action::set_function_map(&amp;function_map); // 添加解service, on, import 解析器 Parser&amp; parser = Parser::GetInstance(); parser.AddSectionParser("service",std::make_unique&lt;ServiceParser&gt;()); parser.AddSectionParser("on", std::make_unique&lt;ActionParser&gt;()); parser.AddSectionParser("import", std::make_unique&lt;ImportParser&gt;()); // 解析init rc文件 parser.ParseConfig("/init.rc"); ActionManager&amp; am = ActionManager::GetInstance(); //执行rc文件中触发器为 on early-init的语句 am.QueueEventTrigger("early-init"); //创建wait_for_coldboot_done 动作并添加到action vector和trigger_queue_中 am.QueueBuiltinAction(wait_for_coldboot_done_action, "wait_for_coldboot_done"); am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng"); am.QueueBuiltinAction(set_mmap_rnd_bits_action, "set_mmap_rnd_bits"); am.QueueBuiltinAction(keychord_init_action, "keychord_init"); am.QueueBuiltinAction(console_init_action, "console_init"); //执行rc文件中触发器为 on init的语句 // Trigger all the boot actions to get us started. am.QueueEventTrigger("init"); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng"); // Don't mount filesystems or start core system services in charger mode. std::string bootmode = property_get("ro.bootmode"); if (bootmode == "charger") &#123; //充电模式下，执行rc文件中触发器为charger的语句 am.QueueEventTrigger("charger"); &#125; else &#123; //非充电模式下，执行rc文件中触发器为late-init的语句 am.QueueEventTrigger("late-init"); &#125; // Run all property triggers based on current state of the properties. // 创建queue_property_triggers动作并且添加到action vector和trigger_queue_中 am.QueueBuiltinAction(queue_property_triggers_action, "queue_property_triggers"); while (true) &#123; if (!waiting_for_exec) &#123; am.ExecuteOneCommand(); // 重启一些关键进程 restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (am.HasMoreCommands()) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; //循环 等待事件发生 int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR("epoll_wait failed: %s\n", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; return 0;&#125; 可以看到，init进程主要以下功能： 是挂载tmpfs, devpts, proc, sysfs文件系统。 是运行init.rc脚本，init将会解析init.rc，并且执行init.rc中的命令。 当一些关键进程死亡时，重启该进程； 提供Android系统的属性服务 3.2 文件系统简介 1. tmpfs文件系统 tmpfs是一种虚拟内存文件系统，因此它会将所有的文件存储在虚拟内存中，并且tmpfs下的所有内容均为临时性的内容，如果你将tmpfs文件系统卸载后，那么其下的所有的内容将不复存在。tmpfs是一个独立的文件系统，不是块设备，只要挂接，立即就可以使用。 2. devpts文件系统 devpts文件系统为伪终端提供了一个标准接口，它的标准挂接点是/dev/pts。只要pty的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文件。 3. proc文件系统 proc文件系统是一个非常重要的虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统的信息，同时也能够在运行时修改特定的内核参数。 4. sysfs文件系统 与proc文件系统类似，sysfs文件系统也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。sysfs文件系统是Linux2.6内核引入的，它把连接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取。 4 init rc文件和语法init rc文件语法是以行尾单位，以空格间隔的语法，以#开始代表注释行。rc文件主要包含Action、Service、Command、Options，其中对于Action和Service的名称都是唯一的，对于重复的命名视为无效。 4.1 动作ActionAction： 通过trigger，即以 on开头的语句，决定何时执行相应的service。 on early-init; 在初始化早期阶段触发； on init; 在初始化阶段触发； on late-init; 在初始化晚期阶段触发； on boot/charger： 当系统启动/充电时触发，还包含其他情况，此处不一一列举； on property:=: 当属性值满足条件时触发； 4.2 服务Service服务Service，以service开头，由init进程启动，一般运行于另外一个init的子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service，在启动时会通过fork方式生成子进程。 例如： service servicemanager /system/bin/servicemanager代表的是服务名为servicemanager，服务的路径，也就是服务执行操作时运行/system/bin/servicemanager。 4.3 命令Command下面列举常用的命令 class_start ： 启动属于同一个class的所有服务； start ： 启动指定的服务，若已启动则跳过； stop ： 停止正在运行的服务 setprop ：设置属性值 mkdir ：创建指定目录 symlink ： 创建连接到的符号链接； write ： 向文件path中写入字符串； exec： fork并执行，会阻塞init进程直到程序完毕； exprot ：设定环境变量； loglevel ：设置log级别 4.4 可选操作OptionsOptions是Services的可选项，与service配合使用 disabled: 不随class自动启动，只有根据service名才启动； oneshot: service退出后不再重启； user/group： 设置执行服务的用户/用户组，默认都是root； class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； onrestart:当服务重启时执行相应命令； socket: 创建名为/dev/socket/的socket critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式 *default: 意味着disabled=false，oneshot=false，critical=false。 所有的Service里面只有servicemanager ，zygote ，surfaceflinger这3个service有onrestart关键字来触发其他service启动过程。 5 Daemon守护进程init.rc会启动一些daemon进程，比如ueventd, adbd, servicemanager, vold, netd, debuggerd等。 1234567891011121314151617181920212223242526272829303132333435363738service ueventd /sbin/ueventd class core critical service console /system/bin/sh class core console disabled user shell group log service adbd /sbin/adbd class core disabled service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm service vold /system/bin/vold class core socket vold stream 0660 root mount ioprio be 2 service netd /system/bin/netd class main socket netd stream 0660 root system socket dnsproxyd stream 0660 root inet socket mdns stream 0660 root system service debuggerd /system/bin/debuggerd class main 6 ServiceManagerServiceManager也是守护进程，它是android的服务大管家，是一个很重要的服务： 1234567891011//servicemanager可触发healthd、zygote、media、surfaceflinger、drm重启service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm service servicemanager /system/bin/servicemanager表示服务名为servicemanager，服务运行的时候会执行/system/bin/servicemanager。 7 ZygoteZygote是第一个Java进程，并且是所有java进程的父进程。在init.zygote32.rc文件中，zygote服务定义如下： 12345678//zygote可触发media、netd重启service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd Zygote入口和相关类： /frameworks/base/cmds/app_process/App_main.cpp （内含AppRuntime类）/frameworks/base/core/jni/AndroidRuntime.cpp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java/frameworks/base/core/java/com/android/internal/os/Zygote.java/frameworks/base/core/java/android/net/LocalServerSocket.java/system/core/libutils/Threads.cpp 解释下第一行参数： zygote : 服务名 systen/bin/app_process : zygote所对应的可执行文件是，通过调用pid =fork()创建子进程 剩下的四个参数是zygote进程的启动参数，其中最后一个参数--start-system-server是表示zygote进程启动完成后，马上将system进程启动起来。 zygote启动过程调用堆栈： 123456789App_main.main() AndroidRuntime.start() StartVM() StartReg() ZygoteInit.main() ResgisterZygoteSocket() preload() startSystemServer() runSelectLoop() zygote进程的主要工作如下： 解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法； 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数； 通过JNI方式调用ZygoteInit.main()，第一次进入Java世界； registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求； preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高ap启动效率； zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。 zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。 8 system_server上面提到Zygote启动过程中会调用startSystemServer()，可知startSystemServer()函数是system_server启动流程的起点， system_server相关类函数如下： /frameworks/base/core/java/android/app/ActivityThread.java/frameworks/base/core/java/android/app/LoadedApk.java/frameworks/base/core/java/android/app/ContextImpl.java/frameworks/base/core/java/com/android/server/LocalServices.java/frameworks/base/services/java/com/android/server/SystemServer.java/frameworks/base/services/core/java/com/android/server/SystemServiceManager.java/frameworks/base/services/core/java/com/android/server/ServiceThread.java/frameworks/base/services/core/java/com/android/server/pm/Installer.java/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 启动流程图如下： 进入到SystemServer.main后，调用堆栈如下：123456789101112SystemServer.main SystemServer.run createSystemContext ActivityThread.systemMain ActivityThread.attach LoadedApk.makeApplication ActivityThread.getSystemContext ContextImpl.createSystemContext startBootstrapServices();//启动引导服务 startCoreServices(); // 启动核心服务 startOtherServices(); // 启动其他服务 Looper.loop(); 有兴趣的读者可以跟着follow源码一步步展开，由于篇幅所限，只做总结归纳，system_server最主要的工作就是启动系统服务。 通过startBootstrapServices(), startCoreServices(), startOtherServices()3个方法。 8.1 startBootstrapServices();[ SystemServer.java ] 启动引导服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void startBootstrapServices() &#123; //阻塞等待与installd建立socket通道 Installer installer = mSystemServiceManager.startService(Installer.class); //启动服务ActivityManagerService mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); //启动服务PowerManagerService mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); //初始化power management mActivityManagerService.initPowerManagement(); //启动服务LightsService mSystemServiceManager.startService(LightsService.class); //启动服务DisplayManagerService mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); //Phase100: 在初始化package manager之前，需要默认的显示. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); //当设备正在加密时，仅运行核心 String cryptState = SystemProperties.get("vold.decrypt"); if (ENCRYPTING_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; //启动服务PackageManagerService mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); //启动服务UserManagerService，新建目录/data/user/ ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); AttributeCache.init(mSystemContext); //设置AMS mActivityManagerService.setSystemProcess(); //启动传感器服务 startSensorService();&#125; 该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， SensorService服务。 8.2 startCoreServices();[ SystemServer.java ] 启动核心服务 1234567891011121314private void startCoreServices() &#123; //启动服务BatteryService，用于统计电池电量，需要LightService. mSystemServiceManager.startService(BatteryService.class); //启动服务UsageStatsService，用于统计应用使用情况 mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); //启动服务WebViewUpdateService mSystemServiceManager.startService(WebViewUpdateService.class);&#125; 启动服务BatteryService，UsageStatsService，WebViewUpdateService。 8.3 startOtherServices()[ SystemServer.java ] 启动其他服务 该方法比较长，有近千行代码，逻辑很简单，主要是启动一系列的服务: 123456789101112131415161718192021222324252627282930313233343536private void startOtherServices() &#123; ... SystemConfig.getInstance(); mContentResolver = context.getContentResolver(); // resolver ... mActivityManagerService.installSystemProviders(); //provider mSystemServiceManager.startService(AlarmManagerService.class); // alarm // watchdog watchdog.init(context, mActivityManagerService); inputManager = new InputManagerService(context); // input wm = WindowManagerService.main(...); // window inputManager.start(); //启动input mDisplayManagerService.windowManagerAndInputReady(); ... mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); // mount mPackageManagerService.performBootDexOpt(); // dexopt操作 ActivityManagerNative.getDefault().showBootMessage(...); //显示启动界面 ... statusBar = new StatusBarManagerService(context, wm); //statusBar //dropbox ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox"))); mSystemServiceManager.startService(JobSchedulerService.class); //JobScheduler lockSettings.systemReady(); //lockSettings //phase480 和phase500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... // 准备好window, power, package, display服务 wm.systemReady(); mPowerManagerService.systemReady(...); mPackageManagerService.systemReady(); mDisplayManagerService.systemReady(...); //见下面分析 mActivityManagerService.systemReady(new Runnable() &#123;...&#125;); 其中AMS.systemReady()的大致过程如下: 12345678910111213141516171819202122public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123; public void systemReady(final Runnable goingCallback) &#123; ... //update相关 mSystemReady = true; //杀掉所有非persistent进程 removeProcessLocked(proc, true, false, "system update done"); mProcessesReady = true; goingCallback.run(); //[见小节1.6.2] addAppLocked(info, false, null); //启动所有的persistent进程 mBooting = true; //启动home startHomeActivityLocked(mCurrentUserId, "systemReady"); //恢复栈顶的Activity mStackSupervisor.resumeTopActivitiesLocked(); &#125;&#125; ActivityManagerService的systemReady方法，在该方法里会启动系统界面以及Home程序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Binder实用指南（二） - 实战篇]]></title>
      <url>%2F2016%2F12%2F25%2Fandroid-binder-02%2F</url>
      <content type="text"><![CDATA[本章的内容主要说明如何在JavaFramework层和Native层自定义Client-Server组件，并且使用Binder进行通信。 1 Native Binder源码目录结构: alps/frameworks/native/cmds/NativeBinderDemo/ 123456|-NativeBinderDemo|---ClientDemo.cpp: 客户端程序|---ServerDemo.cpp：服务端程序|---IMyService.h：自定义的MyService服务的头文件|---IMyService.cpp：自定义的MyService服务|---Android.mk：源码build文件 1.1 服务端 alps/frameworks/native/cmds/NativeBinderDemo/ServerDemo.cpp 获取ServiceManager，注册service.myservice服务到ServiceManager，启动服务。 123456789#include "IMyService.h"int main() &#123; sp &lt; IServiceManager &gt; sm = defaultServiceManager(); //获取service manager引用 sm-&gt;addService(String16("service.myservice"), new BnMyService()); //注册名为"service.myservice"的服务到service manager ProcessState::self()-&gt;startThreadPool(); //启动线程池 IPCThreadState::self()-&gt;joinThreadPool(); //把主线程加入线程池 return 0;&#125; 1.2 客户端 alps/frameworks/native/cmds/NativeBinderDemo/ClientDemo.cpp 获取ServiceManager，拿到service.myservice服务，再进行类型转换成IMyService，最后调用远程方法sayHello() 123456789#include "IMyService.h"int main() &#123; sp &lt; IServiceManager &gt; sm = defaultServiceManager(); //获取service manager引用 sp &lt; IBinder &gt; binder = sm-&gt;getService(String16("service.myservice"));//获取名为"service.myservice"的binder接口 sp&lt;IMyService&gt; cs = interface_cast &lt; IMyService &gt; (binder);//将biner对象转换为强引用类型的IMyService cs-&gt;sayHello();//利用binder引用调用远程sayHello()方法 return 0;&#125; 1.3 MyService alps/frameworks/native/cmds/NativeBinderDemo/IMyService.h 申明IMyService，申明BpMyService（Binder客户端），申明BnMyService（Binder的服务端）。 123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef MY_SERVICE_DEMO#define MY_SERVICE_DEMO#include &lt;stdio.h&gt;#include &lt;binder/IInterface.h&gt;#include &lt;binder/Parcel.h&gt;#include &lt;binder/IBinder.h&gt;#include &lt;binder/Binder.h&gt;#include &lt;binder/ProcessState.h&gt;#include &lt;binder/IPCThreadState.h&gt;#include &lt;binder/IServiceManager.h&gt;using namespace android;namespace android&#123; class IMyService : public IInterface &#123; public: DECLARE_META_INTERFACE(MyService); //使用宏，申明MyService virtual void sayHello()=0; //定义方法 &#125;; //定义命令字段 enum &#123; HELLO = 1, &#125;; //申明客户端BpMyService class BpMyService: public BpInterface&lt;IMyService&gt; &#123; public: BpMyService(const sp&lt;IBinder&gt;&amp; impl); virtual void sayHello(); &#125;; //申明服务端BnMyService class BnMyService: public BnInterface&lt;IMyService&gt; &#123; public: virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); virtual void sayHello(); &#125;;&#125;#endif alps/frameworks/native/cmds/NativeBinderDemo/IMyService.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142#include "IMyService.h"namespace android&#123; IMPLEMENT_META_INTERFACE(MyService, "android.demo.IMyService"); //使用宏，完成MyService定义 //客户端 BpMyService::BpMyService(const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IMyService&gt;(impl) &#123; &#125; // 实现客户端sayHello方法 void BpMyService::sayHello() &#123; printf("BpMyService::sayHello\n"); Parcel data, reply; data.writeInterfaceToken(IMyService::getInterfaceDescriptor()); remote()-&gt;transact(HELLO, data, &amp;reply); printf("get num from BnMyService: %d\n", reply.readInt32()); &#125; //服务端，接收远程消息，处理onTransact方法 status_t BnMyService::onTransact(uint_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) &#123; switch (code) &#123; case HELLO: &#123; //收到HELLO命令的处理流程 printf("BnMyService:: got the client hello\n"); CHECK_INTERFACE(IMyService, data, reply); sayHello(); reply-&gt;writeInt32(2015); return NO_ERROR; &#125; break; default: break; &#125; return NO_ERROR; &#125; // 实现服务端sayHello方法 void BnMyService::sayHello() &#123; printf("BnMyService::sayHello\n"); &#125;;&#125; 1.4 Android.mk12345678910111213141516171819202122232425262728LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS)LOCAL_SHARED_LIBRARIES := \ libcutils \ libutils \ libbinder LOCAL_MODULE := ServerDemoLOCAL_SRC_FILES := \ IMyService.cpp \ ServerDemo.cpp LOCAL_MODULE_TAGS := optionalinclude $(BUILD_EXECUTABLE) include $(CLEAR_VARS)LOCAL_SHARED_LIBRARIES := \ libcutils \ libutils \ libbinderLOCAL_MODULE := ClientDemoLOCAL_SRC_FILES := \ IMyService.cpp \ ClientDemo.cppLOCAL_MODULE_TAGS := optionalinclude $(BUILD_EXECUTABLE) 1.5 原理图 1.6 运行编译：mm alps/frameworks/native/cmds/NativeBinderDemo目录，然后到alps/out/target/product/{Project}/system/bin/会生成ClientDemo和ServerDemo 执行：123adb remountadb push ServerDemo /system/binadb push ClientDemo /system/bin 开两个窗口分别执行下面两个命令便可以看到结果了：adb shell system/bin/ServerDemo ， adb shell system/bin/ClientDemo 2 JavaFramework Binder源码目录结构: alps/frameworks/base/cmds/FrameworkBinderDemo/ 12345678|-Server端|---ServerDemo.java：可执行程序|---IMyService.java: 定义IMyService接口|---MyService.java：定义MyService|-Client端|---ClientDemo.java：可执行程序|---IMyService.java: 与Server端完全一致|---MyServiceProxy.java：定义MyServiceProxy 2.1 Server端(1)ServerDemo.java 可执行程序 123456789101112public class ServerDemo &#123; public static void main(String[] args) &#123; System.out.println("MyService Start"); //准备Looper循环执行 Looper.prepareMainLooper(); //设置为前台优先级 android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND); //注册服务 ServiceManager.addService("MyService", new MyService()); Looper.loop(); &#125;&#125; (2)IMyService.java 定义sayHello()方法，DESCRIPTOR属性 12345public interface IMyService extends IInterface &#123; static final java.lang.String DESCRIPTOR = "com.yuanhh.frameworkBinder.MyServer"; public void sayHello(String str) throws RemoteException ; static final int TRANSACTION_say = android.os.IBinder.FIRST_CALL_TRANSACTION;&#125; (3)MyService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyService extends Binder implements IMyService&#123; public MyService() &#123; this.attachInterface(this, DESCRIPTOR); &#125; @Override public IBinder asBinder() &#123; return this; &#125; /** 将MyService转换为IMyService接口 **/ public static com.yuanhh.frameworkBinder.IMyService asInterface( android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iInterface = obj.queryLocalInterface(DESCRIPTOR); if (((iInterface != null)&amp;&amp;(iInterface instanceof com.yuanhh.frameworkBinder.IMyService)))&#123; return ((com.yuanhh.frameworkBinder.IMyService) iInterface); &#125; return null; &#125; /** 服务端，接收远程消息，处理onTransact方法 **/ @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_say: &#123; data.enforceInterface(DESCRIPTOR); String str = data.readString(); sayHello(str); reply.writeNoException(); return true; &#125;&#125; return super.onTransact(code, data, reply, flags); &#125; /** 自定义sayHello()方法 **/ @Override public void sayHello(String str) &#123; System.out.println("MyService:: Hello, " + str); &#125;&#125; (4) Android.mk 12345678910111213141516LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_MODULE := ServerDemo LOCAL_MODULE_TAGS := optionalinclude $(BUILD_JAVA_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := ServerDemoLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_PATH := $(TARGET_OUT)/binLOCAL_MODULE_CLASS := UTILITY_EXECUTABLESLOCAL_SRC_FILES := ServerDemoinclude $(BUILD_PREBUILT) (5) ServerDemo 123base=/systemexport CLASSPATH=$base/framework/ServerDemo.jarexec app_process $base/bin com.shun.frameworkBinder.ServerDemo &quot;$@&quot; 2.2 Client端(1)ClientDemo.java 可执行程序 12345678910public class ClientDemo &#123; public static void main(String[] args) throws RemoteException &#123; System.out.println("Client start"); IBinder binder = ServiceManager.getService("MyService"); //获取名为"MyService"的服务 IMyService myService = new MyServiceProxy(binder); //创建MyServiceProxy对象 myService.sayHello("binder"); //通过MyServiceProxy对象调用接口的方法 System.out.println("Client end"); &#125;&#125; (2)IMyService.java 与Server端的IMyService是一致，基本都是拷贝一份过来。 (3)MyServiceProxy.java 1234567891011121314151617181920212223242526272829303132public class MyServiceProxy implements IMyService &#123; private android.os.IBinder mRemote; //代表BpBinder public MyServiceProxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** 自定义的sayHello()方法 **/ @Override public void sayHello(String str) throws RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(str); mRemote.transact(TRANSACTION_say, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; @Override public IBinder asBinder() &#123; return mRemote; &#125;&#125; (4) Android.mk 123456789101112131415LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_MODULE := ClientDemo LOCAL_MODULE_TAGS := optionalinclude $(BUILD_JAVA_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := ClientDemoLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_PATH := $(TARGET_OUT)/binLOCAL_MODULE_CLASS := UTILITY_EXECUTABLESLOCAL_SRC_FILES := ClientDemoinclude $(BUILD_PREBUILT) (5) ClientDemo 123base=/systemexport CLASSPATH=$base/framework/ClientDemo.jarexec app_process $base/bin com.shun.frameworkBinder.ClientDemo &quot;$@&quot; 2.3 原理图 2.4 运行编译： mm alps/frameworks/base/cmds/FrameworkBinderDemo/目录，然后：alps/out/target/product/{Project}/system/bin/ 生成ClientDemo和ServerDemoalps/out/target/product/{Project}/system/framework/ 生成ClientDemo.jar和ServerDemo.jar。 执行： 12345adb remountadb push ServerDemo /system/binadb push ClientDemo /system/binadb push ServerDemo.jar /system/framework/adb push ClientDemo.jar /system/framework/ 开两个窗口分别执行下面两个命令便可以看到结果了：adb shell system/bin/ServerDemo ， adb shell system/bin/ClientDemo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Binder实用指南（一） - 理解篇]]></title>
      <url>%2F2016%2F12%2F21%2Fandroid-binder-01%2F</url>
      <content type="text"><![CDATA[这是关于Android Binder机制的一篇文章，Binder是Android里面非常重要的组成，也是最难理解的一块知识点，学习Binder最好的方法是深入源码阅读，因为Binder相关的知识错综复杂，一般初学者也很容易迷失在源码的汪洋里，本文旨在梳理Binder的架构和流程，并且试着以实用的角度来看待Binder。 1 为什么需要Binder机制？Android系统中，每个应用程序是由Android的Activity，Service，Broadcast，ContentProvider这四剑客的中一个或多个组合而成，这四剑客所涉及的多进程间的通信底层都是依赖于Binder IPC机制。例如当进程A中的Activity要向进程B中的Service通信，这便需要依赖于Binder IPC。如果熟悉Android源码，其实可以知道整个Android系统架构中，也大量采用了Binder机制作为IPC（进程间通信）方案。Android是在Linux内核的基础上设计的。而在Linux中，已经拥有”管道/消息队列/共享内存/信号量/Socket等等”众多的IPC通信手段；但是，Google为什么单单选择了Binder，可见Binder肯定有自己独特的优势： 1.1 Binder能很好的实现C/S架构Android系统，很大一部分都是居于Client-Server架构的设计。Client端有什么需求，直接发送给Server端去完成，Server处理完毕再将反馈内容发送给Client。Server端与Client端相对独立，稳定性较好。传统的CS架构只有Socket，但是Socket通信效率相对于其他IPC来说又太低效，而Binder正是基于C/S架构设计的。 1.2 Binder传输效率高Binder只需要进行一次拷贝，把Client端的用户空间的数据即copy_from_user()到内核空间，然后将内核空间的数据映射到Server端的用户空间。Binder性能上仅仅次于Linux 共享内存的方式，但是共享内存的方式，进程间同步又是一个难题。 1.3 Binder安全性极高Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。Client-Server通信过程中，Binder内核会为每个Client进程分配了UID/PID来作为鉴别身份的标示，并且在Binder通信时会根据UID/PID进行有效性检测。而如果是传统的IPC只能由在数据包当中填入UID/PID，这个并不是一个可靠的方法。 知乎上有一位答主讲得很好，可以看看: 为什么 Android 要采用 Binder 作为 IPC 机制? 2 Binder原理 Binder采用Client-Server架构，包含Client、Server、ServiceManager、Binder驱动四个组件。 应用程序都运行在用户空间，每个应用程序都有它自己独立的内存空间；若不同的应用程序之间涉及到通信，需要通过内核进行中转，因为需要用到内核的copy_from_user()和copy_to_user()等函数 Server进程要先注册Service到ServiceManager，Client进程使用某Server的Service前，须先向ServiceManager中获取相应的Service，然后使用Service。 3 Binder驱动层 当用户空间调用open()方法，最终会调用binder驱动的binder_open()方法；mmap()/ioctl()方法也是同理，从用户态进入内核态，都依赖于系统调用过程。 3.1 binder_init注册misc设备，指定相应文件操作的方法。 3.2 binder_open创建binder_proc对象，并把当前进程等信息保存到binder_proc对象，该对象管理IPC所需的各种信息并拥有其他结构体的根结构体；再把binder_proc对象保存到文件指针filp，以及把binder_proc加入到全局链表binder_procs。 3.3 binder_mmap在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。 3.4 binder_ioctl负责在两个进程间收发IPC数据和IPC reply数据。调用流程比如：123456789101112//step 1:binder_write_read bwr;ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) // step 2: binder_ioctl(filp, BINDER_WRITE_READ, &amp;bwr) // step 3: binder_ioctl_write_read(filp, BINDER_WRITE_READ, &amp;bwr, thread) // step 4: copy_from_user(&amp;bwr, ubuf, sizeof(bwr)) binder_thread_write(proc, thread, bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); copy_to_user(...) binder_thread_write()：处理Binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；binder_thread_read()：生成Binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层； 4 Binder通信流程例如当名为BatteryStatsService的Client向ServiceManager注册服务的过程中，IPC层的数据组成为：Handle=0，RPC代码为ADD_SERVICE_TRANSACTION，RPC数据为BatteryStatsService，Binder协议为BC_TRANSACTION。整个流程图大致如下： handle为0正是指向ServiceManager。 5 启动ServiceManagerServiceManager启动时序图： 打开binder驱动，并调用mmap()方法分配128k的内存映射空间：binder_open(); 通知binder驱动使其成为守护进程：binder_become_context_manager()； 验证selinux权限，判断进程是否有权注册或查看指定服务； 进入循环状态，等待Client端的请求：binder_loop()。 6 获取ServiceManager获取Service Manager是通过defaultServiceManager()方法来完成，当进程注册服务(addService)或 获取服务(getService)的过程之前，都需要先调用defaultServiceManager()方法来获取gDefaultServiceManager对象。 获取ProcessState对象，在其构造函数中调用open_driver函数打开Binder驱动，并将句柄保存到mDriverFD； 调用gProcess-&gt;getContextObject函数来获得一个句柄值为0的Binder引用，即BpBinder； 通过interface_cast构造一个BpServiceManager对象，所以gDefaultServiceManager最终为new BpServiceManager(new BpBinder(0))。 7 addService以Native层的服务以media服务为例，注册MediaPlayerService的时序图如下： defaultServiceManager()返回的是BpServiceManager，会调用BpServiceManager.addService方法 addService()通过remote()中保存的BpBinder调用到IPCThreadState的transact方法； IPCThreadState::transact会调用writeTransactionData()传输数据传输数据，然后和驱动交互，驱动把请求转发给ServiceManager执行真正的注册服务； 得到驱动的返回后，调用BBinder，最终调用到BnMediaPlayerService的onTransact方法； 开启两个线程不断和Binder进行交互，获取Client请求。 获取服务的流程基本也是差不多的，不再累述。 8 Binder架构binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。 1.BinderProxy类代码Client端,Binder类代表Server端2.framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理 比如addService流程：1.java层通过getIServiceManager获得ServiceManagerProxy对象，通过该对象的BinderProxy，最终会调用BpBinder对象，由BpBinder来完成通信。2.Binder驱动将Client端的请求转发给BBinder的transact方法，然后由其子类JavaBBinder调用。后者会调用指定Service的方法，并返回给驱动。 9 Binder类图9.1 Native Binder类图 9.2 Framework Binder类图 10 Binder其他介绍一些Binder其他比较重要的点，方便理清Binder的一些疑问。比如Binder实体和引用，比如ProcessState和IPCThreadState，比如数据结构怎么传递等。 10.1 Binder中各个角色的关系 1. Binder实体 : binder_node Binder实体，是各个Server以及ServiceManager在内核中的存在形式。Binder实体实际上是内核中 binder_node 结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。 2. Binder引用 : binder_ref 所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。Binder实体和Binder引用都是内核(即Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。 3. 远程服务 Server都是以服务的形式注册到ServiceManager中进行管理的。如果将Server本身看作是”本地服务”的话，那么Client中的”远程服务”就是本地服务的代理。如果你对代理模式比较熟悉的话，就很容易理解了，远程服务就是本地服务的一个代理，通过该远程服务Client就能和Server进行通信。 10.2 进程和线程的关系 图解：1.Binder驱动通过binder_procs链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应。2.每个进程有且只有一个ProcessState对象，这是通过单例模式来保证的。3.每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是Binder_thread结构体。在binder_proc结构体中通过成员变量rb_root threads，来记录当前进程内所有的binder_thread。 Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。 10.3 Binder数据传输 当Client向Server发送请求时，Client会将数据打包成上述格式，然后通过ioctl()发送给Binder驱动。 用户空间的进程调用ioctl(fd,BINDER_WRITE_READ,&amp;bwr)时传递给Binder驱动的信息。fd是Binder驱动的文件句柄，BINDER_WRITE_READ是ioctl()的一个标识，而bwr是传递的数据，write_buffer是请求数据的内容，而write_consumed是用来记录请求数据中已经被Binder驱动处理过的数据的大小。 ioctl会走到binder_thread_write和binder_thread_read。这层的数据是”事务指令”+”binder_transaction_data结构体”组成的。data是保存事务中具体数据的内存地址。具体调用流程可以参考#3.4章节 这层是有效数据。如果该请求是传递给ServiceManager进行处理的，则有效数据是：消息头+”Server的相关信息”。消息头是用来进行有效性检查的，而”Server的相关信息”则是请求要处理的信息。 11 源码目录从上之下, 整个Binder架构所涉及的总共有以下5个目录:12345/framework/base/core/java/ (Java)/framework/base/core/jni/ (JNI)/framework/native/libs/binder (Native)/framework/native/cmds/servicemanager/ (Native)/kernel/drivers/staging/android (Driver) 11.1 Java framework12345678910111213/framework/base/core/java/android/os/ - IInterface.java - IBinder.java - Parcel.java - IServiceManager.java - ServiceManager.java - ServiceManagerNative.java - Binder.java /framework/base/core/jni/ - android_os_Parcel.cpp - AndroidRuntime.cpp - android_util_Binder.cpp (核心类) 11.2 Native framework1234567891011121314/framework/native/libs/binder - IServiceManager.cpp - BpBinder.cpp - Binder.cpp - IPCThreadState.cpp (核心类) - ProcessState.cpp (核心类)/framework/native/include/binder/ - IServiceManager.h - IInterface.h/framework/native/cmds/servicemanager/ - service_manager.c - binder.c 11.3 Kernel123/kernel/drivers/staging/android/ - binder.c - uapi/binder.h]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android消息机制]]></title>
      <url>%2F2016%2F12%2F11%2Fandroid-looper-handler-message%2F</url>
      <content type="text"><![CDATA[本文介绍Android的消息机制。 1 引言假设现在我们有这样的需求，点一下图中的button，然后去获取一些数据（假设这个步骤是一个耗时的操作），然后获取完后将得到的数据返回显示到屏幕上。为了避免产生ANR(Application Not Response)问题，通常我们会在新的线程去做耗时的操作，然后在UI线程里面更新组件，所以Handler就是类似这样子一个机制。 那么我们会怎么去实现呢？可以参考如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestDriverActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = (TextView)findViewById(R.id.tv); btn = (Button)findViewById(R.id.btn); // 接收并处理消息 mHandler = new Handler()&#123; @Override public void handleMessage(Message msg)&#123; if (message.what == 0x11)&#123; Toast.makeText(getApplicationContext(), "mHandler handleMessage" ); tv.setText("mHandler is receive message") &#125; &#125; &#125;; // 监听 btn.setOnClickListener(new View.onClickListener()&#123; @Override public void onClick(View v)&#123; MyThread t = new MyThread(mHandler); t.start(); &#125; &#125;); &#125;&#125;class MyThread extends Thread&#123; Handler handler; public MyThread(Handler handler) &#123; super(); this.handler = handler; &#125; @Override public void run()&#123; super.run(); mHandler.sendEmptyMessage(0x11); //发送消息 &#125;&#125; 这只是一种实现的方式，如果在子线程而不是ui线程去初始化handler，则需要初始化handler前调用Looper.prepare()，初始化结束后调用Looper.loop()。 2 相关概念学习Android的消息处理机制，有几个概念（类）必须了解： Message消息，理解为线程间通讯的数据单元。例如后台线程在处理数据完毕后需要更新UI，则可发送一条包含更新信息的Message给UI线程。 Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。 HandlerHandler是Message的主要处理者，负责将Message添加到消息队列以及对消息队列中的Message进行处理。 Looper循环器，扮演Message Queue和Handler之间桥梁的角色，循环取出Message Queue里面的Message，并交付给相应的Handler进行处理。 ThreadUI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。 3 LooperLooper被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单： 123456789101112public class LooperThread extends Thread &#123; @Override public void run() &#123; // 将当前线程初始化为Looper线程 Looper.prepare(); // ...其他处理，如实例化handler // 开始循环处理消息队列 Looper.loop(); &#125;&#125; 3.1 Looper.prepare()当执行了Looper.prepare()后，当前线程就会升级为Looper线程： 一个Thread只能有一个Looper对象 线程中有一个Looper对象，它的内部维护了一个消息队列MessageQueue 3.2 Looper.loop()当调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。 那么，我们如何往MQ上添加消息呢？下面有请Handler 4 HandlerHandler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即往MQ上添加消息的时候执行sendMessage，并在loop到自己的时候处理消息执行handleMessage，整个过程是异步的。 Handler创建时会关联一个looper，默认关联当前线程的looper。 public class LooperThread extends Thread { private Handler handler1; private Handler handler2; @Override public void run() { // 将当前线程初始化为Looper线程 Looper.prepare(); // 实例化两个handler handler1 = new Handler(); handler2 = new Handler(); // 开始循环处理消息队列 Looper.loop(); } } 加入Handler后结构图如下： 一个线程可以有多个Handler，但是只能有一个Looper。 4.1 Handler发送消息和处理消息大致流程： mHandler.sendMessage()发送消息到MQ Looper.loop()将message不断从MQ从取出来交给handler处理 mHandler.handleMessage()处理消息 5 回顾那么回到一开始我们举的例子，在非UI线程去做耗时的操作，然后完成后在UI线程更新UI信息。那么这种case下，我们的结构图是这样的： 至此，本文介绍的内容已经完成，本文内容大部分非原创，更多的是基于其他博客的和自己理解的总结，好记性不如烂笔头。如果需要了解源码的同学，可以继续深入阅读研究，包括Java层Looper，Handler，Message，MessageQueue的源码和Native层Looper，NativeMessageQueue的源码实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[引用计数 Android智能指针]]></title>
      <url>%2F2016%2F12%2F10%2Fcpp-ref-count%2F</url>
      <content type="text"><![CDATA[引用计数机制 以前学cocos写游戏的时候有接触过这个概念。 引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。 1 什么是引用计数简单来讲，当我们创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。 2 什么是智能指针？C语言、C++语言没有自动内存回收机制，关于内存的操作的安全性依赖于程序员的自觉。程序员每次new出来的内存块都需要自己使用delete进行释放，流程复杂可能会导致忘记释放内存而造成内存泄漏。而智能指针也致力于解决这种问题，使程序员专注于指针的使用而把内存管理交给智能指针。 3 使用引用计数来实现智能指针了解了引用计数，我们可以使用它来写我们的智能指针类了。 3.1 基础对象类首先，我们来定义一个基础对象类Student类，这个是我们实际使用的对象，我们为Student类创建如下接口： 123456class Student &#123;public: Student()&#123; cout&lt;&lt;"Student()"; &#125; ~Student()&#123; cout&lt;&lt;"~Student()";&#125;&#125;; 3.2 辅助管理类在创建智能指针类之前，我们先创建一个辅助管理类。这个类的所有成员皆为私有类型，因为它不被普通用户所使用。为了只为智能指针使用，还需要把智能指针类声明为辅助类的友元。这个辅助类含有两个数据成员：引用计数count与基础对象指针。也即辅助类用以封装使用计数与基础对象指针。 123456789101112template &lt;typename T&gt;class U_Ptr &#123;private: friend class SmartPtr; //友元类能直接操作U_Ptr类成员 U_Ptr(T *ptr) :p(ptr), count(1) &#123; &#125; //初始化1 ~U_Ptr() &#123; delete p; &#125; //虚析构函数 int count; // 引用计数 T *p; // 实际的对象 &#125;; 3.3 智能指针类设计一个智能指针类SmartPtr类，我们这里只关注rp指针和构造函数、析构函数。rp是基础管理类，SmartPtr类通过rp来间接增加或者减少引用计数count，当引用计数为0，则delete rp，而rp的析构函数，会去释放真正的对象。 123456789101112131415161718192021222324template &lt;typename T&gt;class SmartPtr&#123;public: SmartPtr(T *ptr) :rp(new U_Ptr(ptr)) &#123; &#125; //构造函数 SmartPtr(const SmartPtr &amp;sp) :rp(sp.rp) &#123; ++rp-&gt;count; &#125; //复制构造函数 SmartPtr&amp; operator=(const SmartPtr&amp; rhs) &#123; //赋值函数 ++rhs.rp-&gt;count; if (--rp-&gt;count == 0) delete rp; rp = rhs.rp; return *this; &#125; ~SmartPtr() &#123; //析构函数（虚函数） if (--rp-&gt;count == 0) delete rp; else cout &lt;&lt; "还有" &lt;&lt; rp-&gt;count &lt;&lt; "个指针指向基础对象" &lt;&lt; endl; &#125; private: U_Ptr *rp; &#125;; 4 使用示例123456789101112131415161718192021222324int main()&#123; //定义一个基础对象类指针 Student *pS = new Student(); //定义三个智能指针类对象，对象都指向基础类对象pa //使用花括号控制三个指针指针的生命期，观察计数的变化 &#123; SmartPtr&lt;Student&gt; sptr1(pS);//此时计数count=1 &#123; SmartPtr&lt;Student&gt; sptr2(sptr1); //调用复制构造函数，此时计数为count=2 &#123; SmartPtr&lt;Student&gt; sptr3=sptr1; //调用赋值操作符，此时计数为conut=3 &#125; //此时count=2 &#125; //此时count=1； &#125; //此时count=0；pS对象被delete掉 system("pause"); return 0;&#125; 引用计数实现的方式多种多样，上面是一种比较简单的参考实现。 5.Android智能指针原始的引用计数无法解决循环引用问题。什么是循环引用？举一个简单例子： 系统中有两个对象A和B，在对象A的内部引用了对象B，而在对象B的内部也引用了对象A。当两个对象A和B都不再使用时，垃圾收集系统会发现无法回收这两个对象的所占据的内存的，因为系统一次只能收集一个对象，而无论系统决定要收回对象A还是要收回对象B时，都会发现这个对象被其它的对象所引用，因而就都回收不了，这样就造成了内存泄漏。 这样，就要采取另外的一种引用计数技术了，即对象的引用计数同时存在强引用和弱引用两种计数。比如Android的智能指针。 5.1 强指针和弱指针Android中定义了两种智能指针类型，一种是强指针sp（strong pointer），一种是弱指针（weak pointer）。其实成为强引用和弱引用更合适一些。强指针与一般意义的智能指针概念相同，通过引用计数来记录有多少使用者在使用一个对象，如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁。 弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，也就是说不能通过弱智真来调用对象的成员函数或访问对象的成员变量。要想访问弱指针所指向的对象，需首先将弱指针升级为强指针（通过wp类所提供的promote()方法）。弱指针所指向的对象是有可能在其它地方被销毁的，如果对象已经被销毁，wp的promote()方法将返回空指针，这样就能避免出现地址访问错的情况。 每一个可以被智能指针引用的对象都同时被附加了另外一个 weakref_impl类型的对象，这个对象中负责记录对象的强指针引用计数和弱指针引用计数。这个对象是Android智能指针的实现内部使用的，智能指针的使用者看不到这个对象。弱指针操作的就是这个对象，只有当强引用计数和弱引用计数都为0时，这个对象才会被销毁。 5.2 使用Android智能指针假如我有一个类MyClass要使用智能指针，那么需要满足两个条件： （1） 这个类是RefBase的子类或间接子类； （2） 这个类必须定义虚构造函数 : ~MyClass(){} 强指针12sp&lt; MyClass&gt; p_obj = new MyClass(); p_obj-&gt;func() 弱指针123wp&lt; MyClass&gt; wp_obj = new MyClass(); p_obj = wp_obj.promote(); // 用.而不是-&gt; p_obj-&gt;func(); 相关源码： http://androidxref.com/4.4_r1/xref/system/core/include/utils/RefBase.h http://androidxref.com/4.4_r1/xref/system/core/include/utils/StrongPointer.h 如果需要了解Android智能指针的实现，可以参考老罗的一篇文章：http://blog.csdn.net/luoshengyang/article/details/6786239]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python RSA文件加密]]></title>
      <url>%2F2016%2F11%2F20%2Fpython-rsa%2F</url>
      <content type="text"><![CDATA[本文教你如何用Python对文件进行不对称加密。 引言前段时间，一个同学找到我说他的电脑中病毒了，电脑上所有重要的文件都变成了*.cryp1，打也打不开，大学生涯的重要文件都没有了，很着急所以让我帮忙看看。嗯，作为程序员的觉悟，第一反应就是开始找资料，看看这个是什么鬼。 Google了一番后，发现这个病毒的名字叫特斯拉勒索者，会把你电脑上的一些文件进行加密，变成*.cryp1，并留下一个比特币支付的链接，让你打钱过去，不打钱就不给你解密的方法，那么如果你中毒了，那么只能恭喜你了！因为除了作者把私钥放出来，否则基本上没有破解的可能。 为什么这么说呢？病毒会对文件进行不对称加密，也就是公钥加密算法。只要保证你的密钥长度足够长，那么基本上就没有破解的可能。为什么这么说呢？你可以想象一下银行卡交易被破解的后果。 1 RSA简介RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA就是他们三人姓氏开头字母拼在一起组成的。RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 RSA算法的原理，目前网络上有许多优秀的文章，特别推荐阅读阮一峰老师的文章： RSA算法原理1 RSA算法原理2 本文主要描述如何使用RSA来对文件进行不对成加密。 2 PyCryptoPyCrypto是Python中密码学方面比较有名的第三方软件包。可惜的是，它的开发工作于 2012 年就已停止。幸运的是，有一个该项目的分支 PyCrytodome 取代了PyCrypto，可以支持Python3.5，在Windows上，我们可以直接安装： 1py -3 -m pip install PyCrytodome 相关文档可以直接访问： 例子说明 API说明 3 文件加密准备好环境之后，那么我们现在来开始模拟黑客对文件进行加密处理吧！！如果前面有了解RSA算法的话，那么肯定知道，我们第一步就是要生成公钥和私钥，用公钥对文件进行加密，用私钥对文件进行解密。 3.1 生成公钥和私钥在这个例子中，我们将生成自己的密钥对。创建 RSA 密钥非常容易： 12345678910111213from Crypto.PublicKey import RSAdef CreateRSAKeys(): code = 'nooneknows' # 生成 2048 位的 RSA 密钥 key = RSA.generate(2048) encrypted_key = key.exportKey(passphrase=code, pkcs=8, protection="scryptAndAES128-CBC") # 生成私钥 with open('my_private_rsa_key.bin', 'wb') as f: f.write(encrypted_key) # 生成公钥 with open('my_rsa_public.pem', 'wb') as f: f.write(key.publickey().exportKey()) 当我们执行CreateRSAKeys()后，会在当前目录生成公钥和私钥，我们打开看看。 公钥：123456789-----BEGIN RSA PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzVRRmo7R3VPtsUz/uBBi/Ofb/5NKMoylH6xnFfH3WaN8oTj9706xxrNmuJ0kc4QVNDofKKogfotjVRDbe6FT7JoH9NclCNEvfiaOWnwXV6srPYBfQb7pCl4cfQ23U/EOFR2SRAIO9yYy5z8vToG3shSPKcs3dXGfnzYaJcvCwcG8Dmk09S2wLTdo7ZqPp5erG5eYa2ohV0B94SQyHvUkBl5iYlkH0zUdnif7u47xziAM2HtWB2xMB7l3ckaltuN6qPvXkyaz50HUTbZRhVFniHd5iaseAYxD74uLw5TYmj8s5A33lPO4oJe868ukgUl0DMSF48OX2OO4TrhYZEFJBwIDAQAB-----END RSA PUBLIC KEY----- 私钥：123456789101112131415161718192021222324252627282930-----BEGIN ENCRYPTED PRIVATE KEY-----MIIFJTBPBgkqhkiG9w0BBQ0wQjAhBgkrBgEEAdpHBAswFAQI2zONWIfQCF4CAkAAAgEIAgEBMB0GCWCGSAFlAwQBAgQQLRSUFPMMc6Zds4C/tu2lKwSCBNDtbdkpf3un1hQz8nJ0x91m6FH3esDz+IGSjVBMFAT0uy5TiKv/2u3glj+sgFEM7aLOeaX3QoukkEm5L73J28qEeZ3hqNoaMmYdzAaHuCOjHubXaii3AoKTg4PXO9Qy4v/IICTj5CQqSMSSFXlkSmfz7u4WzwQzM1LOwSwLuHVJElVCxiOBA7m4dJgNNd6iRIPyTLh2ECiKwrMgkaGbQIxYN7RMt9tm2cL5z6Ah8sRBjlDbM1QSnOEyY9NPrWqHyT/R1enjLkQpDiZUtxp5A9yjE1QEiKBvqIKTMDhGcXK1S7KXo7DWYOMpU1zZp0dLWKFmyNmi6b9Htu/HYFcV6pDDA3x+yVnDZsxcDJ/iaJJ7v6qFI04dukVbkr977PHTaUj9AbmQZf/KhnBr2BmL65h84oPhnxVk50g//DAiorPUZ5BEFNdOExlW/eiUezG+n86vtqd3VFYZ/LMlse6C+fLiwHRTbbJx2jRiIbpcBOdUcqLxdjUsFiUtuwZeh9A/9Zu3GJjd0kp2Itp1I9wrI9l56msSfO6n5//11Jjtc1ANxcJY9np1julboEyhS5H25PojXL7moUy5yWbzPe9I9xodLJGIpa0FqmEM2O0AuV4CCO3QzbVMc3fOY264wxHnIMhMhQocD9dyR1TNtfb3A5Hsj3nLVcFgpUj9WdrHfmxPAgcY2LCSxVhrKaitjUMDi3ea5G5G6DeZf5/+Vc0M4gxyeyn7fp5DY6AEdNea2P+4UPsXdUw74jExHiYv0Zx07kGjM9Qwvg9fGUhDJvMtxuFGjBqy4wnYwGx3PvHPljONPhxpE2naXlhjsi0K39Q6P+o+bTYOBZBlicdup4feaZ9AtcN8fU3kFKPnkbQ9fLwTGA8UuJAguBW95jJ5trT8tmn4o0y3O61fnGyN3JyzwaI/fPi8QavqUti3cSTxcYDr9oXBU1ND9YLB8LKgnXE9LD3kg0a6w6kEdJPpf9OTeMFb85wf/bEviof0CgK/fGcz9DxuRvJLRLPwTfXXh3stZ33Rky/MuX1h5qmd7eDXEZmFWvi73P5R61+xGHxgarP9Ww7bX6EcC7HN9xg2QcWHDusdWaw/HE9J1pHxCzOQoxE4SclqEtTo3J9fXhQgKfKih7azWP1PpTsjvZ/J4ZwZeGWUDXzk54opDg8PFEhAPsyRt94iKP+oKb3zHYpkcuU4UAk8+fPznZ+1hIvboryn3CfV6t29dyGE9R3VCCPLBrpy4DJhvuITjlZdeh6fhUV4SOXjUBEhNn+6wv3L3U3INvXIwfJssAf+boXk4lf209HcGz05Q6dFyN106q7UjWK/e+ometiD/wL51DoRBnS5CfrW9U1o4m4PI23mKeoaf0i7SoPz2vVF7w7vEzXXgk7wO4bN0AqeFjCMFw/hOQqZrNHcIWchsmiPwCqwj/FSGHIzGvppbTPr8qudMlXmaL1xGbyJAOAJW+qVaEwzJx7wvrchehGwzYbIYuGuWfYqKIh4+1VgQyafDuO13o5TeqdZa3ghgWiRpJse7KabbVgHLyBfxMvVuIpHqpM3qaTqsp4CICPuCFVoB5HReu0V7l1gfN++Tjo5BLV5rijyhWjnlUDRXqntnXqA2RC9vOpNMZ6L8Fp6VvA9i3ZI9RvkkeI2rw==-----END ENCRYPTED PRIVATE KEY----- 当然每次运行的结果都不一定，公钥是公开的，任何人都可以看到，但是私钥一定要保存好，否则一旦泄露，意味着你的信息也不安全了。 3.2 利用公钥对文件进行加密现在我们来看看如何对文件进行加密处理： 123456789101112131415161718192021222324252627from Crypto.Cipher import AES, PKCS1_OAEPfrom Crypto.Random import get_random_bytesdef Encrypt(filename): data = '' # 二进制只读打开文件，读取文件数据 with open(filename, 'rb') as f: data = f.read() with open(filename, 'wb') as out_file: # 收件人秘钥 - 公钥 recipient_key = RSA.import_key(open('my_rsa_public.pem').read()) #一个 16 字节的会话密钥 session_key = get_random_bytes(16) # Encrypt the session key with the public RSA key cipher_rsa = PKCS1_OAEP.new(recipient_key) out_file.write(cipher_rsa.encrypt(session_key)) # Encrypt the data with the AES session key cipher_aes = AES.new(session_key, AES.MODE_EAX) ciphertext, tag = cipher_aes.encrypt_and_digest(data) out_file.write(cipher_aes.nonce) out_file.write(tag) out_file.write(ciphertext) 我们打开一个文件用于写入数据。接着我们导入公钥赋给一个变量，创建一个 16 字节的会话密钥。在这个例子中，我们将使用混合加密方法，即 PKCS#1 OAEP ，也就是最优非对称加密填充。这允许我们向文件中写入任意长度的数据。接着我们创建 AES 加密，要加密的数据，然后加密数据。我们将得到加密的文本和消息认证码。最后，我们将随机数，消息认证码和加密的文本写入文件。 加密后，这个时候你肯定没有办法按照原来的方式打开你的文件了，或者你能打开，显示的也是乱码。 3.3 利用私钥对文件进行解密现在让我们学习如何解密我们的文件数据： 1234567891011121314151617181920from Crypto.PublicKey import RSAfrom Crypto.Cipher import AES, PKCS1_OAEPdef Descrypt(filename): code = 'nooneknows' with open(filename, 'rb') as fobj: # 导入私钥 private_key = RSA.import_key(open('my_private_rsa_key.bin').read(), passphrase=code) # 会话密钥， 随机数，消息认证码，机密的数据 enc_session_key, nonce, tag, ciphertext = [ fobj.read(x) for x in (private_key.size_in_bytes(), 16, 16, -1) ] cipher_rsa = PKCS1_OAEP.new(private_key) session_key = cipher_rsa.decrypt(enc_session_key) cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce) # 解密 data = cipher_aes.decrypt_and_verify(ciphertext, tag) with open(filename, 'wb') as wobj: wobj.write(data) 我们先以二进制模式读取我们的加密文件，然后导入私钥。注意，当你导私钥时，需要提供一个密码，否则会出现错误。然后，我们文件中读取数据，首先是加密的会话密钥，然后是 16 字节的随机数和 16 字节的消息认证码，最后是剩下的加密的数据。 接下来我们需要解密出会话密钥，重新创建 AES 密钥，然后解密出数据。 解密完成后，我们会发现刚刚打不开或者无法正确显示的文件，又恢复正常了！ 4 文件名处理当然至此，文件加密的部分已经完成，但是为了使这个更像病毒，我们可以模拟黑客的做法，直接把整个文件的后缀名改掉，或者更混蛋一点，我就是想搞破坏，直接把文件名字改成一串没有意义的数值： 4.1 文件重命名举例比如：blog2.rar ==&gt; yFmcuIzZvxmY.crypt1 123456789101112131415import osimport base64def RenameFile(dir,filename): filename_bytes = filename.encode('utf-8') filename_bytes_base64 = base64.encodestring(filename_bytes) filename_bytes_base64 = filename_bytes_base64[::-1][1:] # 倒序 new_filename = filename_bytes_base64.decode('utf-8') + '.crypt1' #print (new_filename) print(os.path.join(dir, filename)) print(os.path.join(dir,new_filename)) os.rename(os.path.join(dir, filename), os.path.join(dir,new_filename)) 使用了base64对文件名进行编码。 4.2 恢复文件名举例比如: yFmcuIzZvxmY.crypt1 ==&gt; blog2.rar 123456789101112import osimport base64def ReserveFilename(dir, filename): f = filename filename = filename[::-1][7:][::-1] filename_base64 = filename[::-1] + '\n' filename_bytes_base64 = filename_base64.encode('utf-8') ori_filename = base64.decodestring(filename_bytes_base64).decode('utf-8') print(os.path.join(dir, f)) print(os.path.join(dir,ori_filename)) os.rename(os.path.join(dir, f),os.path.join(dir,ori_filename)) 使用了base64对文件进行解码。 5 完整源码我们把上述几个过程整合起来，然后实现对某一个目录下的所有文件进行不对称加密和不对称解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#coding=utf-8from Crypto.PublicKey import RSAfrom Crypto.Random import get_random_bytesfrom Crypto.Cipher import AES, PKCS1_OAEPimport osimport base64def CreateRSAKeys(): code = 'nooneknows' key = RSA.generate(2048) encrypted_key = key.exportKey(passphrase=code, pkcs=8, protection="scryptAndAES128-CBC") # 私钥 with open('my_private_rsa_key.bin', 'wb') as f: f.write(encrypted_key) # 公钥 with open('my_rsa_public.pem', 'wb') as f: f.write(key.publickey().exportKey())def Encrypt(filename): data = '' with open(filename, 'rb') as f: data = f.read() with open(filename, 'wb') as out_file: # 收件人秘钥 - 公钥 recipient_key = RSA.import_key(open('my_rsa_public.pem').read()) session_key = get_random_bytes(16) # Encrypt the session key with the public RSA key cipher_rsa = PKCS1_OAEP.new(recipient_key) out_file.write(cipher_rsa.encrypt(session_key)) # Encrypt the data with the AES session key cipher_aes = AES.new(session_key, AES.MODE_EAX) ciphertext, tag = cipher_aes.encrypt_and_digest(data) out_file.write(cipher_aes.nonce) out_file.write(tag) out_file.write(ciphertext) def Descrypt(filename): code = 'nooneknows' with open(filename, 'rb') as fobj: private_key = RSA.import_key(open('my_private_rsa_key.bin').read(), passphrase=code) enc_session_key, nonce, tag, ciphertext = [ fobj.read(x) for x in (private_key.size_in_bytes(), 16, 16, -1) ] cipher_rsa = PKCS1_OAEP.new(private_key) session_key = cipher_rsa.decrypt(enc_session_key) cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce) data = cipher_aes.decrypt_and_verify(ciphertext, tag) with open(filename, 'wb') as wobj: wobj.write(data) def RenameFile(dir,filename): filename_bytes = filename.encode('utf-8') filename_bytes_base64 = base64.encodestring(filename_bytes) filename_bytes_base64 = filename_bytes_base64[::-1][1:] new_filename = filename_bytes_base64.decode('utf-8') + '.crypt1' print(os.path.join(dir, filename)) print(os.path.join(dir,new_filename)) os.rename(os.path.join(dir, filename), os.path.join(dir,new_filename))def ReserveFilename(dir, filename): f = filename filename = filename[::-1][7:][::-1] filename_base64 = filename[::-1] + '\n' filename_bytes_base64 = filename_base64.encode('utf-8') ori_filename = base64.decodestring(filename_bytes_base64).decode('utf-8') print(os.path.join(dir, f)) print(os.path.join(dir,ori_filename)) os.rename(os.path.join(dir, f),os.path.join(dir,ori_filename)) def Main(rootDir): list_dirs = os.walk(rootDir) for root, dirs, files in list_dirs: # 切换加密和解密过程 #if False: if True: # 遍历文件，加密并且改名 for f in files: filename = os.path.join(root, f) Encrypt(filename) RenameFile(root, f) else: # 遍历文件，解密并且恢复名字 for f in files: filename = os.path.join(root, f) Descrypt(filename) ReserveFilename(root, f) if __name__ == '__main__': #CreateRSAKeys() d = 'D:\\des' Main(d)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask源码阅读]]></title>
      <url>%2F2016%2F10%2F24%2Fflask-source-reading%2F</url>
      <content type="text"><![CDATA[Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。 我们先从flask 0.1版本阅读起。 1 安装Flask 0.1因为flask 0.1暂时不支持python3，所以我们使用python2.7版本： 1py -2 -m pip install flask==0.1 2 Hello World这是一个很简单的示例，编写hello.py，参考官方网站的示例： 12345678from flask import Flaskapp = Flask(__name__)@app.route("/")def hello(): return "Hello World!" if __name__ == "__main__": app.run() 运行hello.py后，打开浏览器访问 localhost:5000可以看到浏览器输出Hello World!。 3 知识准备在对flask有了一个比较简单的认识之后，我们知道，flask是基于Jinja2和Werkzeug的一个框架，其WSGI工具箱采用Werkzeug，模板引擎则使用 Jinja2。 3.1 WSGIWSGI是Web Server Gateway Interface的缩写，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。引用一张图说明WSGI的位置： WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个hello world： 1234567# args:# - environ：一个包含所有HTTP请求信息的dict对象；# - start_response：一个发送HTTP响应的函数。#def application(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'] 上面的application()函数就是符合WSGI标准的一个HTTP处理函数，函数必须由WSGI服务器来调用。 environ是一个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做environment（编码中多简写为environ、env） start_response返回了http响应的header，Header只能发送一次，也就是这个函数只能调用一次。有很多符合WSGI规范的服务器，我们可以挑选一个来用。比如： 123456from eventlet import wsgiimport eventletdef hello_world(environ, start_response): start_response('200 OK', [('Content-Type', 'text/plain')]) return ['Hello, World!\r\n']wsgi.server(eventlet.listen(('', 8090)), hello_world) 3.2 Jinja2 Jinja2是一个模板引擎，jinja2内部使用Unicode，一个比较简单的示例如下： 1234from jinja2 import Templatetemplate = Template('Hello &#123;&#123; name &#125;&#125;!')s = template.render(name='Shun')print(s) # Hello Shun! 或者 1234from jinja2 import Environment, PackageLoaderenv = Environment(loader = PackageLoader('module_name', 'templates_dir'))template2 = env.get_template('my_template.html') # 'Hello &#123;&#123; name &#125;&#125;!'s = template2.render(name = 'shun') # Hello shun! 更高级的用法可以参考官方文档 : http://docs.jinkan.org/docs/jinja2/ 3.3 WerkzeugWerkzeug是一个WSGI工具包，官网将其描述为：The Python WSGI Utility Library。一个简单的例子实现一个小的 Hello World 应用。显示用户输入的名字: 1234567891011121314151617from werkzeug.utils import escapefrom werkzeug.wrappers import Request, Response@Request.applicationdef hello_world(request): result = ['&lt;title&gt;Greeter&lt;/title&gt;'] if request.method == 'POST': result.append('&lt;h1&gt;Hello %s!&lt;/h1&gt;' % escape(request.form['name'])) result.append(''' &lt;form action="" method="post"&gt; &lt;p&gt;Name: &lt;input type="text" name="name" size="20"&gt; &lt;input type="submit" value="Greet me"&gt; &lt;/form&gt; ''') return Response(''.join(result), mimet ype='text/html')if __name__ == '__main__': from werkzeug.serving import run_simple run_simple('localhost', 8080, hello_world) 另外不用 request 和 response 对象也可以实现这个功能，那就是借助 werkzeug 提供的 解析函数: 123456789101112131415from werkzeug.formparser import parse_form_datafrom werkzeug.utils import escapedef hello_world(environ, start_response): result = ['&lt;title&gt;Greeter&lt;/title&gt;'] if environ['REQUEST_METHOD'] == 'POST': form = parse_form_data(environ)[1] result.append('&lt;h1&gt;Hello %s!&lt;/h1&gt;' % escape(form['name'])) result.append(''' &lt;form action="" method="post"&gt; &lt;p&gt;Name: &lt;input type="text" name="name" size="20"&gt; &lt;input type="submit" value="Greet me"&gt; &lt;/form&gt; ''') start_response('200 OK', [('Content-Type', 'text/html; charset=utf-8')]) return [''.join(result)] 通常我们更倾向于使用高级的 API(request 和 response 对象)。但是也有些情况你可能更 想使用低级功能。 4 Flask-0.1源码分析有了上面的基础之后，我们可以开始分析Flask的源码了。完整的源码可以参考这里：Flask.py首先我们再来回顾一下Hello World是怎么样的： 12345678from flask import Flaskapp = Flask(__name__) @app.route("/")def hello(): return "Hello World!"if __name__ == "__main__": app.run() 先初始化一个Flask的类，然后路由hello方法，最后再run起来。 4.1 Flask init()我们来分析一下Flask类的初始化函数： 1234567891011121314151617181920212223242526272829303132333435363738394041class Flask(object): request_class = Request response_class = Response static_path = '/static' secret_key = None session_cookie_name = 'session' # 模板参数 jinja_options = dict( autoescape=True, extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_'] ) def __init__(self, package_name): self.debug = False # 如果设置为True，则改完code后，服务器会自动部署（reload） self.package_name = package_name # __main__ self.root_path = _get_package_path(self.package_name) self.view_functions = &#123;&#125; # 保存url视图函数名到函数地址的映射 self.error_handlers = &#123;&#125; # 保存错误函数，@app.errorhandler(404)... self.before_request_funcs = [] # 保存request前执行的一些函数，比如打开数据库等 self.after_request_funcs = [] # 保存request后执行的一些函数 self.template_context_processors = [_default_template_ctx_processor] self.url_map = Map() # ??? if self.static_path is not None: self.url_map.add(Rule(self.static_path + '/&lt;filename&gt;', build_only=True, endpoint='static')) if pkg_resources is not None: target = (self.package_name, 'static') else: target = os.path.join(self.root_path, 'static') self.wsgi_app = SharedDataMiddleware(self.wsgi_app, &#123; self.static_path: target &#125;) self.jinja_env = Environment(loader=self.create_jinja_loader(), **self.jinja_options) self.jinja_env.globals.update( url_for=url_for, get_flashed_messages=get_flashed_messages ) template_context_processors的内容涉及context，这个后面再讲。 self.url_map这个函数保存了URI（访问的后缀URL,比如/，/index/等）到视图函数字典的映射,我们可以看到路由这个函数是如何实现的： 123456789101112131415# rule : URI比如 '\'# options : 这里是空的字典 &#123;&#125;，用于后面保存URI对应的访问规则，比如GET or POST，函数名等。def route(self, rule, **options): # f指向实际执行的函数地址 def decorator(f): self.add_url_rule(rule, f.__name__, **options) self.view_functions[f.__name__] = f return f return decorator# rule : URI# endpoint : 函数名字符串def add_url_rule(self, rule, endpoint, **options): options['endpoint'] = endpoint options.setdefault('methods', ('GET',)) self.url_map.add(Rule(rule, **options)) 假如我们写了： 123app.route(&apos;/&apos;)def hello(): print(&apos;hello shun.&apos;) 相当于执行了: 1hello = app.route('/')(hello) 对装饰器不太熟悉的同学，可以参考我的另外一篇文章:Python 装饰器decorator 4.2 wsgi_app当我们执行app.run函数的时候,最终会执行到wsgi_app函数，这个函数是Flask的入口核心函数： 1234app.run() run_simple(host, port, self, **options) __call__(self, environ, start_response) wsgi_app(self, environ, start_response) 最终会执行wsgi_app，这个函数是flask的入口，也是核心： 12345678def wsgi_app(self, environ, start_response): with self.request_context(environ): # 创建request context rv = self.preprocess_request() # 先调用预处理函数 if rv is None: rv = self.dispatch_request() # 分发请求 response = self.make_response(rv) # response = self.process_response(response) return response(environ, start_response) 4.2.1 生成request_context我们一个一个来分析，先看是如何创建request context的： 1234567891011121314151617# Flask类函数def request_context(self, environ): return _RequestContext(self, environ)# _RequestContext类class _RequestContext(object): def __init__(self, app, environ): self.app = app # Flask app self.url_adapter = app.url_map.bind_to_environ(environ) # 将ENV绑定到URL Adappter，可以参考werkzeug相关文档说明 self.request = app.request_class(environ) # app.request = Request类，其实就是把environ字典的一些信息封装为Request对象 self.session = app.open_session(self.request) # 从cookie中拿到sessionID，然后读取用户的session self.g = _RequestGlobals() self.flashes = None def __enter__(self): _request_ctx_stack.push(self) def __exit__(self, exc_type, exc_value, tb): if tb is None or not self.app.debug: _request_ctx_stack.pop() URL Adappter更多，可以点击这里 : Werkzeug 文档说明 关于Session和Cookie，我这里多补充几句： Session是在服务端保存的一个数据结构，用来对用户会话进行跟踪的一个机制，根据不同的Session ID来标识不同的用户，这个数据可以保存在集群、数据库、文件中。常见的使用场景，比如购物车等。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。 Session ID一般是存在Cookie中，所以如果浏览器禁用了Cookie，同时Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） 4.2.2 预处理preprocess_request我们再来看看先调用预处理函数preprocess_request： 1234567def preprocess_request(self): for func in self.before_request_funcs: rv = func() if rv is not None: # 如果这些函数中有返回值，则被视为来自试图的返回值，并停止其他函数处理 # 预处理函数应当不需要有返回值的，这点需注意 return rv 会遍历before_request_funcs这个列表的函数并且执行，这个列表函数通过装饰器@app.before_request来赋值： 1234def before_request(self, f): """Registers a function to run before each request.""" self.before_request_funcs.append(f) return f 4.2.3 分发请求dispatch_request()简单一句话，这个函数的作用就是匹配到Request对应的URL和视图函数，并执行这个函数： 123456789101112131415161718192021def match_request(self): rv = _request_ctx_stack.top.url_adapter.match() # self.url_adapter 上文有说明 # endpoint 是指函数名 # view_args 这里是一个dict，视图参数？？ request.endpoint, request.view_args = rv return rvdef dispatch_request(self): try: endpoint, values = self.match_request() # 先匹配函数名和参数 return self.view_functions[endpoint](**values) # 匹配完后直接执行函数 except HTTPException, e: # 匹配不到视图函数的处理 handler = self.error_handlers.get(e.code) if handler is None: return e return handler(e) except Exception, e: handler = self.error_handlers.get(500) if self.debug or handler is None: raise return handler(e) 4.2.4 生成response对象生成一个response对象，并返回： 1234567891011# ResponseBase由Werkzeug提供,class Response(ResponseBase): default_mimetype = 'text/html'def make_response(self, rv): if isinstance(rv, self.response_class): return rv if isinstance(rv, basestring): return self.response_class(rv) if isinstance(rv, tuple): return self.response_class(*rv) return self.response_class.force_type(rv, request.environ) 如果不是response对象，则转化response对象，response对象继承自ResponseBase对象，其实就是Response对象。若需要进一步了解，可以访问：http://werkzeug-docs-cn.readthedocs.io/zh_CN/latest/quickstart.html#response 4.2.5 self.process_response(response)生成response对象后，保存session并执行一些request后的函数，最后再返回response对象： 1234567def process_response(self, response): session = _request_ctx_stack.top.session # 从RequestContext中拿到用户的session if session is not None: self.save_session(session, response) # 保存session for handler in self.after_request_funcs: response = handler(response) # 执行装饰器 @app.after_request 标记的函数 return response # 最后返回response对象 在所有都处理完成后，把需要返回的内容返回给客户端： 1return response(environ, start_response) 至此，flask 0.1主框架大致分析完成了。 5 Flask Context机制细心的同学在上面应该注意到了，我们还有一个点没有讲，那就是Flask的Context机制。 Flask 中有分为请求上下文和应用上下文： 对象 Context类型 说明 current_app AppContext 当前应用的对象 g AppContext 处理请求时用作临时存储的对象 request RequestContext 请求request对象 session RequestContext 请求的session对象 拉到Flask.py最后面，我们可以看到有以下几行： 12345_request_ctx_stack = LocalStack()current_app = LocalProxy(lambda: _request_ctx_stack.top.app)request = LocalProxy(lambda: _request_ctx_stack.top.request)session = LocalProxy(lambda: _request_ctx_stack.top.session)g = LocalProxy(lambda: _request_ctx_stack.top.g) 所有的对象都交由request_ctx_stack这个堆栈来管理了。 5.1 LocakStack()LocalStack()会返回一个栈。栈肯定会有push 、pop和top函数，如下所示: 12345678910111213141516171819202122232425262728293031323334353637class LocalStack(object): """ &gt;&gt;&gt; ls = LocalStack() &gt;&gt;&gt; ls.push(42) &gt;&gt;&gt; ls.top 42 &gt;&gt;&gt; ls.push(23) &gt;&gt;&gt; ls.top 23 &gt;&gt;&gt; ls.pop() 23 &gt;&gt;&gt; ls.top 42 """ def __init__(self): self._local = Local() def push(self, obj): rv = getattr(self._local, 'stack', None) if rv is None: self._local.stack = rv = [] rv.append(obj) return rv def pop(self): stack = getattr(self._local, 'stack', None) if stack is None: return None elif len(stack) == 1: release_local(self._local) return stack[-1] else: return stack.pop() @property def top(self): try: return self._local.stack[-1] except (AttributeError, IndexError): return None 按照我们的理解，要实现一个栈，那么LocalStack类应该有一个成员变量，是一个list，然后通过 这个list来保存栈的元素。然而，LocalStack并没有一个类型是list的成员变量， LocalStack仅有一个成员变量self._local = Local()。 我们再看push，pop，top函数可以知道，具体是通过self._local.stack这个来实现栈的操作。 5.2 Local()当我们操作self._local.stack时，会调用Local()的getattr和setattr方法。 1234567891011121314151617class Local(object): __slots__ = ('__storage__', '__ident_func__') def __init__(self): object.__setattr__(self, '__storage__', &#123;&#125;) object.__setattr__(self, '__ident_func__', get_ident) def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; Local类有两个成员变量，分别是storage和ident_func，其中，前者 是一个字典，后者是一个函数。这个函数的含义是，获取当前线程的id。 例如，当我们执行： 12request_ctx_stack = LocalStack()_request_ctx_stack.push(RequestContext) 注意，这里赋值的时候，最终会调用： 12# name =&gt; stackself.__storage__[self.__ident_func__()][name] = RequestContext 所以最终看起来会是这样一个数据结构： 1234&#123; &apos;thread_id1&apos;:&#123;&apos;stack&apos;:[_RequestContext()]&#125;, &apos;thread_id2&apos;:&#123;&apos;stack&apos;:[_RequestContext()]&#125;&#125; 至此，Flask0.1版本的源码已经大致分析完成，其实如果继续下去的话，还有很多值得深究的地方，待后续有时间继续深入分析。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android四大组件]]></title>
      <url>%2F2016%2F08%2F11%2Fandroid-base%2F</url>
      <content type="text"><![CDATA[复习Android四大组件内容。 本文会总结介绍Android组件中最为常见用的四大组件：Activity，Service服务,ContentProvider内容提供者，BroadcastReceiver广播接收者。 1 Activity在一个android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。Activity之间通过Intent进行通信。 1.1 主要函数 1.2 生命周期 1.3 AndroidManifest.xml文件配置需要在apk的AndroidManifest配置文件中进行配置： 1.4 Activity管理activity在android里面是以栈的形式管理的，处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。如下： 1.5 通信 activity之间通过Intent进行通信，可以将数据放入Bundle中，再将Bundle放入intent中，实现数据通信。 可以通过intent去启动一个activity，方式有显示Intent和隐式Intent。2.1 显示直接指明启动的Activity类：Context.startActivity(new Intent(this,xxx.class))2.2 隐式需要在Activity对应的AndroidManifest.xml中配置对应的Intent-Filter中的action和category，一般默认category属性需要有一个default属性(如果有其它category则不用添加此属性)：&lt;category android:name=”android.Intent.Category.DEFAULT” /&gt;这是因为Android把所有传给startActivity()的隐式意图当作他们包含至少一个类别&quot;android.intent.category.DEFAULT&quot; 2 ServiceService作为Android四大组件之一，在每一个应用程序中都扮演着非常重要的角色。它主要用于在后台处理一些耗时的逻辑，或者去执行某些需要长期运行的任务。必要的时候我们甚至可以在程序退出的情况下，让Service在后台继续保持运行状态。 2.1 生命周期Service生命周期函数比较简单： 2.2 Local/Remote Service service分为local service 和 remote service，本地服务的生命周期是和主进程相关的，主进程结束的时候service也结束了，远程服务则为独立的进程和主进程没有关系。 local service 使用bindService启动service，用unBindService关闭service remote service 使用startService和stopService启动和关闭Service 通信：4.1 Local service ：是运行在主进程的main线程下的，在同一个进程，通信的方式通过返回一个IBinder，然后比如说可以在ui线程中去接收ibinder进行通信，可以吧。4.2 Remote service：因为是独立进程，所以如果需要和其它进程进行通信，则需要通过aidl进行ipc通信 如果需要比较耗时的操作，可以在service中开一个新的线程进行操作，避免阻塞ui线程产生anr，或者使用IntentService，因为IntentService会开启单独的线程来处理所有的Intent请求 关于Service其他本文不做过多说明，都是一些比较常用的知识。 3 BroadcastReceiverBroadcastReceiver即广播接受者，是一种全局的监听器，可以用来作为不同组件之间的通信，比如说activity和service之间的通信可以借助其实现。 3.1 启动方式Context.sendBroadcast() 或者Context.sendOrderedBroadcast() 3.2 接收方式重写BroadcastReceiver的onReceive()方法 3.3 实现方式BoradcastReceiver实现方式有两种，一是通过代码注册，二是通过Androidmanifest.xml方式配置： 方式一，代码： 123IntentFilter filter = new IntentFilter(“xxx.xxx.xxx.xxxAction”);XxxReceiver receiver = XxxReceiver();Context.registerReceiver( receiver,filter); 方式二，Androidmanifest.xml12345&lt; receiver android:name = ".XxxReceiver" &gt; &lt; intent-filter android:priority=”1000”&gt; &lt; action android:name = " xxx.xxx.xxx.xxxAction" /&gt; &lt;/ intent-filter &gt;&lt;/ receiver &gt; 每次广播事件发生后，系统会创建对应的BroadcastReceiver实例，并且去触发onReceive方法，这个方法执行完毕后，BroadcastReceiver实例会被销毁，因为BroadcastReceiver生命周期短，超过10s会产生anr对话框，所以不要在onReceive里面做一些耗时的操作，如果需要耗时操作，可以用Intent开启一个Service来完成而不是开启一个新的子线程去完成，因为可能子线程还没结束，BroadcastReceiver就已经结束退出了。 3.4 普通广播和有序广播 普通广播：普通广播是完全异步的，即发送一个广播，所有注册了action相同的BroadcastReceiver都能同时接收到，传递的效率比较高。 有序广播：顾名思义，需要设置广播的顺序，设置的方式有两种，一种是在代码中：IntentFilter.setPriority(Int order)设置，一种是在AndroidManifest.xml中设置&lt; intent-filter android:priority=”1000”&gt;，order值范围为[-1000, 1000]，1000为最高优先级，也就是说当你发送了一个广播，优先级高的BroadcastReceiver会先接收，然后传递给下一个优先级低的BroadcastReceiver，层层传递，然后还可以在优先级高的终止广播的往下传递，或者可以向下一个广播传递新的数据信息，具体方式如下优先级高的广播发送信息： 12345678Bundle bundle = new Bundle();bundle.putString(“info”,”优先级高的就是爽！！”);setResultExtras(bundle);// 甚至可以取消广播继续传递// abortBroadcast()优先级低的接收信息：Bundle bundle = getResultExtras(true);String info = bundle.getString(“info”); 4 ContentProviderContentProvider即内容提供者，简单来讲它的作用就是将一个app的数据提供给其它app进行操作，比如增删改查等。一个典型的例子，比如说我们会经常遇到有应用软件需要读取手机的联系人，这时候就需要联系人应用的ContentProvider功能提供数据的crud操作。ContentProvider的功能是提供数据的增删改查，而其它应用想访问ContentProvider的crud操作，则需要通过ContentResolver的增删改查功能实现，通过uri作为媒介，比如其它应用想去读取联系人，则模型如下： 4.1 URIuri由三部分组成，协议+主机名+路径： scheme： ContentProvider（内容提供者）的scheme已经由Android所规定为：content://。 主机名（或Authority）： 用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。 路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：要操作contact表中id为10的记录，可以构建这样的路径: /contact/10 一个uri例子：1content://com.shun.provider.myapp/contact/2 如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下： 1Uri uri = Uri.parse("content://com.changcheng.provider.contactprovider/contact") 4.2 实现ContentProvider实现一个ContentProvider有两个步骤： 开发一个ContentProvider的子类，然后去实现它的query，delete，update，insert方法，然后还要使用UriMatcher对uri进行匹配过滤 在androidmanifest.xml中配置它，需要指定android:authorities方法（唯一主机名）1&lt;provider android:name=&quot;MyProvider&quot; android:authorities=&quot; com.shun.provider.myapp &quot; /&gt; 4.3 ContentResolverContentResolver的使用则比较简单了：1234Context.getContentResolver().query(…)Context.getContentResolver().delete(…)Context.getContentResolver().update(…)Context.getContentResolver().insert(…) 当然，上面这些个crud方法返回值肯定不一样，具体参考google官网 4.4 ContentObserverContentObserver即内容观察者，可以监听ContentProvider数据的改变，实现一个内容观察者步骤如下： 实现一个ContentObserver的子类，实现onChange()方法，每当有数据改变时会触发此方法 注册监听器，比如监听短信信息：12Uri smsUri = Uri.parse("content://sms"); getContentResolver().registerContentObserver(smsUri, true, new smsContentObserver());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python每日编程训练]]></title>
      <url>%2F2016%2F08%2F10%2Fpython-show-me-the-code%2F</url>
      <content type="text"><![CDATA[python 编程练习 python 每日编程训练。（本文使用Python 3.5） 来源于 - https://github.com/Yixiaohan/show-me-the-code 本文以问题加源码的形式发布。 第 0000 题第 0000 题：将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 类似于图中效果 1234567891011from PIL import Imagefrom PIL import ImageDraw, ImageFontimage = Image.open('0000.png', 'r')font = ImageFont.truetype('c:/Windows/Fonts/Arial.ttf', 36)draw = ImageDraw.Draw(image)w,h = image.size#左上角draw.text(xy=(10, 10), text='9', fill=(255,0,0,255), font=font)image.save('0000-new.png', 'png') 第 0001 题第 0001 题：做为 Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？ 12345import uuidfor i in range(200): # the str length is 32 bytes print(i, ' ====&gt; ' , ''.join(str(uuid.uuid4()).split('-'))) 第 0002 题第 0002 题：将 0001 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。 123456789101112131415161718192021222324252627282930import uuidimport sqlite3# create databaseconn = sqlite3.connect('0002.db')cursor = conn.cursor()sql = 'create table if not exists save_code (id varchar(20) primary key, save_code varchar(50), is_use varchar(10))'cursor.execute(sql)for i in range(200): # generate str, length is 32 bytes s = ''.join(str(uuid.uuid4()).split('-')) print(i, ' ====&gt; ' , s) # insert into sqlite3 try: insert_sql = "insert into save_code (id, save_code, is_use) values ('%s', '%s', '%s')" %(str(i), s, 'no') cursor.execute(insert_sql) except: print('you had insert the save_code') break# select and checkselect_sql = 'select * from save_code'rs = cursor.execute(select_sql).fetchall()for r in rs: print(r)# close resourcecursor.close()conn.commit()conn.close() 第 0003 题第 0003 题：将 0001 题生成的 200 个激活码（或者优惠券）保存到 Redis 非关系型数据库中。 123456789101112import uuidimport redisr = redis.Redis(host='127.0.0.1', port=6379, db=0)for i in range(200): # generate str, length is 32 bytes s = ''.join(str(uuid.uuid4()).split('-')) print(i, ' ====&gt; ' , s) r.lpush('save_code',s)r.flushdb() 第 0004 题第 0004 题：任一个英文的纯文本文件，统计其中的单词出现的个数。 123456789101112131415import rewith open('doc.txt', 'r') as f: data = f.read() words = re.compile(r'([a-zA-Z]+)').findall(data)dicts = &#123;&#125;for word in words: if dicts.get(word) == None: dicts[word] = 1 else: dicts[word] = dicts[word] + 1 for k in dicts: print(k, ' ==&gt; ', dicts[k]) 第 0005 题第 0005 题：你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。 1234567891011121314151617import osfrom PIL import Imageimages = [ x for x in os.listdir('.') if os.path.splitext(x)[1] == '.png' or os.path.splitext(x)[1] == '.png']iphone5_w = 64iphone5_h = 113for image in images: print() img = Image.open(image, 'r') w, h = img.size scaleXY = max(w / iphone5_w, h / iphone5_h) print(scaleXY) if scaleXY &gt; 1.0 : img.thumbnail((w/scaleXY, h/scaleXY)) img.save(os.path.splitext(image)[0]+'_n'+os.path.splitext(image)[1], os.path.splitext(image)[1][1:]) 第 0006 题第 0006 题：你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 1234567891011121314151617181920212223import reimport osDIR_NAME = 'dir'docs = os.listdir(DIR_NAME)for doc in docs: with open(os.path.join(DIR_NAME,doc), 'r') as f: data = f.read() words = re.compile(r'([a-zA-Z]+)').findall(data) dicts = &#123;&#125; for word in words: if dicts.get(word) == None: dicts[word] = 1 else: dicts[word] = dicts[word] + 1 maxValue = max(dicts.values()) for k in dicts: if dicts[k] == maxValue: print(doc, ' ==&gt; ', k,dicts[k]) 第 0007 题第 0007 题：有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。 1234567891011121314151617181920212223242526272829import osDIR_NAME = 'dir'docs = os.listdir(DIR_NAME)for doc in docs: lines = 0 comment_lines = 0 blank_lines = 0 with open(os.path.join(DIR_NAME,doc), 'r', encoding = 'utf8', errors = 'ignore') as f: multi_comment_line_start = 0 for line in f.readlines(): lines += 1 # 忽略所有空格 line = line.split() if len(line) == 0: blank_lines += 1 elif line[0].startswith('#'): comment_lines += 1 elif line[0].startswith("'''") and multi_comment_line_start == 0: multi_comment_line_start = lines elif line[0].startswith("'''"): comment_lines = comment_lines + (lines - multi_comment_line_start + 1) multi_comment_line_start = 0 print('========================') print(doc,' : ') print('lines',lines) print('comment_lines', comment_lines) print('blank_lines', blank_lines) 第 0008 题第 0008 题：一个HTML文件，找出里面的正文。 1234567from bs4 import BeautifulSoupimport requestsurl = 'http://www.baidu.com'page = requests.get(url)soup = BeautifulSoup(page.text, 'html.parser')print(soup.getText()) 第 0009 题第 0009 题：一个HTML文件，找出里面的链接。 12345678from bs4 import BeautifulSoupimport requestsurl = 'http://www.baidu.com'page = requests.get(url)soup = BeautifulSoup(page.text, 'html.parser')for link in soup.find_all('a'): print(link.get('href')) 第 0010 题第 0010 题：使用 Python 生成类似于下图中的字母验证码图片 123456789101112131415161718192021222324252627282930313233from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar(): return chr(random.randint(65, 90))# 随机颜色1:用于填充背景def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:用于绘制字母def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))# 240 x 60:width = 60 * 4height = 60image = Image.new('RGB', (width, height), (255, 255, 255))# 创建Font对象:font = ImageFont.truetype('c:/Windows/Fonts/Arial.ttf', 36)# 创建Draw对象:draw = ImageDraw.Draw(image)# 填充每个像素:for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor())# 输出文字:for t in range(4): draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())# 模糊:image = image.filter(ImageFilter.BLUR)image.save('code.jpg', 'jpeg') 第 0011 题第 0011 题： 敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 12345678910111213141516filename = 'filtered_words.txt'with open(filename, 'r') as f: words = f.read().split()while True: s = input('请输入单词&gt;&gt;&gt;') freedom = False for word in words: if word in s: print('Freedom') freedom = True break if not freedom: print('Human Rights') 第 0012 题第 0012 题： 敏感词文本文件 filtered_words.txt，里面的内容 和 0011题一样，当用户输入敏感词语，则用 星号 替换，例如当用户输入「北京是个好城市」，则变成「*是个好城市」。 12345678910111213141516171819filename = 'filtered_words.txt'with open(filename, 'r') as f: words = f.read().split()while True: s = input('请输入单词&gt;&gt;&gt;') freedom = False for word in words: if word in s: # ** 替换原有字符串 nPos = s.index(word) nStr = ''.join(['*' for c in word ]) s = s.replace(word, nStr) freedom = True print(s) break if not freedom: print('Human Rights') 第 0013 题第 0013 题： 用 Python 写一个爬图片的程序，爬 这个链接里的日本妹子图片 :-) 12345678910111213141516import requestsfrom bs4 import BeautifulSoup url = 'http://tieba.baidu.com/p/2166231880'page = requests.get(url)soup = BeautifulSoup(page.text, 'html.parser')n = 0for line in soup.find_all('img', attrs=&#123;'class':'BDE_Image'&#125;): img_url = line.get('src') img_content = requests.get(img_url).content filename = img_url[-10:] with open(filename, 'wb') as f: f.write(img_content) print(n, 'image %s is download completed.' % filename) n += 1 第 0014 题第 0014 题： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { “1”:[“张三”,150,120,100], “2”:[“李四”,90,99,95], “3”:[“王五”,60,66,68]}请将上述内容写到 student.xls 文件中： 12345678910111213141516171819202122232425import jsonimport xlwt# jsonstr to python dict datawith open('student.txt') as f: dicts = json.loads(f.read())# create xlsxls = xlwt.Workbook()table = xls.add_sheet('student')# write xlsrow = 0col = 0for k in sorted(dicts.keys()): col = 0 table.write(row, col, k) col += 1 for v in dicts[k]: table.write(row, col, v) col += 1 row += 1 # save to xlsxls.save('student.xls') 第 0015 题第 0015 题： 纯文本文件 city.txt为城市信息, 里面的内容（包括花括号）如下所示： { “1” : “上海”, “2” : “北京”, “3” : “成都”}请将上述内容写到 city.xls 文件中 12345678910111213141516171819202122import jsonimport xlwt# jsonstr to python dict datawith open('city.txt') as f: dicts = json.loads(f.read())# create xlsxls = xlwt.Workbook()table = xls.add_sheet('city')# write xlsrow = 0col = 0for k in sorted(dicts.keys()): col = 0 table.write(row, col, k) table.write(row, col + 1, dicts[k]) row += 1 # save to xlsxls.save('city.xls') 第 0016 题第 0016 题： 纯文本文件 numbers.txt, 里面的内容（包括方括号）如下所示：[ [1, 82, 65535], [20, 90, 13], [26, 809, 1024]]请将上述内容写到 numbers.xls 文件中 123456789101112131415161718192021222324import jsonimport xlwt# jsonstr to python dict datawith open('numbers.txt') as f: lists = json.loads(f.read())print(lists)# create xlsxls = xlwt.Workbook()table = xls.add_sheet('numbers')# write xlsrow = 0col = 0for k in lists: col = 0 for v in k: table.write(row, col, v) col += 1 row += 1 # save to xlsxls.save('numbers.xls') 第 0017 题第 0017 题：将 第 0014 题中的 student.xls 文件中的内容写到 student.xml 文件中，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;students&gt; &lt;!-- 学生信息表 &quot;id&quot; : [名字, 数学, 语文, 英文] --&gt; { &quot;1&quot; : [&quot;张三&quot;, 150, 120, 100], &quot;2&quot; : [&quot;李四&quot;, 90, 99, 95], &quot;3&quot; : [&quot;王五&quot;, 60, 66, 68] } &lt;/students&gt; &lt;/root&gt; 代码： 1234567891011121314151617181920212223242526272829import xml.etree.ElementTree as ETimport xlrd# read xlsxls = xlrd.open_workbook('student.xls')table = xls.sheet_by_name('student')dicts = &#123;&#125;for i in range(table.nrows): row = table.row_values(i) dicts[row[0]] = row[1:]# json.dumps无法解决dict的排序问题,所以手动拼接json stringtext = ''text += '\n&#123;\n'for k in sorted(dicts.keys()): lists = dicts[k] s = " \"%s\" : [\"%s\", %d, %d, %d],\n" % (k, lists[0], lists[1], lists[2], lists[3]) text += stext += '&#125;\n'text = text[::-1].replace(',','',1)[::-1] # 翻转字符串，去掉第一个逗号，再翻转回来#save to xmlroot = ET.Element('root')students = ET.SubElement(root, 'students')students.append(ET.Comment(u"""学生信息表 "id" : [名字, 数学, 语文, 英文]""" ))students.text = texttree = ET.ElementTree(root)tree.write('student.xml', encoding='utf-8', xml_declaration=True) 第 0018 题第 0018 题： 将 第 0015 题中的 city.xls 文件中的内容写到 city.xml 文件中，如下所示： &lt;?xmlversion=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;citys&gt; &lt;!-- 城市信息 --&gt; { &quot;1&quot; : &quot;上海&quot;, &quot;2&quot; : &quot;北京&quot;, &quot;3&quot; : &quot;成都&quot; } &lt;/citys&gt; &lt;/root&gt; 12345678910111213141516171819202122import xml.etree.ElementTree as ETimport jsonimport xlrdxls = xlrd.open_workbook('city.xls')table = xls.sheet_by_name('city')# get json stringd = &#123;&#125;for i in range(table.nrows): row = table.row_values(i) d[row[0]] = row[1]json_str = json.dumps(d, ensure_ascii=False)# save to xmlroot = ET.Element('root')citys = ET.SubElement(root, 'citys')citys.append(ET.Comment('城市信息'))citys.text = json_strtree = ET.ElementTree(root)tree.write('citys.xml', encoding = 'utf-8', xml_declaration = True) 第 0019 题第 0019 题： 将 第 0016 题中的 numbers.xls 文件中的内容写到 numbers.xml 文件中，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;numbers&gt; &lt;!-- 数字信息 --&gt; [ [1, 82, 65535], [20, 90, 13], [26, 809, 1024] ] &lt;/numbers&gt; &lt;/root&gt; 代码： 1234567891011121314151617181920212223import xml.etree.ElementTree as ETimport jsonimport xlrdxls = xlrd.open_workbook('numbers.xls')table = xls.sheet_by_name('numbers')# get json stringl = []for i in range(table.nrows): row = table.row_values(i) l.append(row)json_str = json.dumps(l, ensure_ascii=False)print(json_str)# save to xmlroot = ET.Element('root')citys = ET.SubElement(root, 'numbers')citys.append(ET.Comment('数字信息'))citys.text = json_strtree = ET.ElementTree(root)tree.write('numbers.xml', encoding = 'utf-8', xml_declaration = True) 第 0020 题第 0020 题： 登陆中国联通网上营业厅 后选择「自助服务」 –&gt; 「详单查询」，然后选择你要查询的时间段，点击「查询」按钮，查询结果页面的最下方，点击「导出」，就会生成类似于 2014年10月01日～2014年10月31日通话详单.xls 文件。写代码，对每月通话时间做个统计。 1234567891011import xlrdxls = xlrd.open_workbook('src.xls')table = xls.sheet_by_index(0)total_time = 0for i in range(1,table.nrows): row = table.row_values(i) total_time += int(row[3])print('total time : %d s' % total_time)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git笔记]]></title>
      <url>%2F2016%2F07%2F01%2Fgit-note%2F</url>
      <content type="text"><![CDATA[好记性不如烂笔头，把常用的GIT命令在这里记录一下。 1 Git流程图 workspace: 本地的工作目录。（记作A） index：缓存区域，临时保存本地改动。（记作B） local repository: 本地仓库，只想最后一次提交HEAD。（记作C） remote repository：远程仓库。（记作D） 2 新建12345git init //当前目录初始化为GIT代码库git init [project-name] //新建一个目录，将其初始化为Git代码库git clone [url] //检出git config --global user.email &quot;you@example.com&quot; //配置emailgit config --global user.name &quot;Name&quot; //配置用户名 3 操作1234567891011git add &lt;file&gt; // 文件添加，A → Bgit add . // 所有文件添加，A → Bgit commit -m &quot;代码提交信息&quot; //文件提交，B → Cgit commit --amend //与上次commit合并, *B → Cgit push origin master //推送至master分支, C → Dgit pull //更新本地仓库至最新改动， D → Agit fetch //抓取远程仓库更新， D → Cgit log //查看提交记录git status //查看修改状态git diff//查看详细修改内容git show//显示某次提交的内容 4 撤销操作123456git reset &lt;file&gt;//某个文件索引会回滚到最后一次提交， C → Bgit reset//索引会回滚到最后一次提交， C → Bgit reset --hard // 索引会回滚到最后一次提交， C → B → Agit checkout // 从index复制到workspace， B → Agit checkout -- files // 文件从index复制到workspace， B → Agit checkout HEAD -- files // 文件从local repository复制到workspace， C → A 5 分支相关123456git checkout -b branch_name //创建名叫“branch_name”的分支，并切换过去git checkout master //切换回主分支git branch -d branch_name // 删除名叫“branch_name”的分支git push origin branch_name //推送分支到远端仓库git merge branch_name // 合并分支branch_name到当前分支(如master)git rebase //衍合，线性化的自动， D → A 6 冲突处理1234git diff //对比workspace与indexgit diff HEAD //对于workspace与最后一次commitgit diff &lt;source_branch&gt; &lt;target_branch&gt; //对比差异git add &lt;filename&gt; //修改完冲突，需要add以标记合并成功 7 其他1234git diff //对比workspace与indexgit diff HEAD //对于workspace与最后一次commitgit diff &lt;source_branch&gt; &lt;target_branch&gt; //对比差异git add &lt;filename&gt; //修改完冲突，需要add以标记合并成功 关于Git更详细可以参考： Git完整命令地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python中的@classmethod和@staticmethod]]></title>
      <url>%2F2016%2F05%2F17%2Fpython-classmethod-staticmethod%2F</url>
      <content type="text"><![CDATA[花两分钟了解什么是实例方法，类方法，静态方法。 1. 定义python中类方法和静态方法是用装饰器@classmethod和@staticmethod来定义的。 点我学习什么是装饰器 我们先来看一个简单的实例： 1234567891011class A(object): def foo(self,x): print ("executing foo(%s,%s)"%(self,x)) @classmethod def class_foo(cls,x): print ("executing class_foo(%s,%s)"%(cls,x)) @staticmethod def static_foo(x): print ("executing static_foo(%s)"%x) 我们定义了一个class A，类A里面分别定义了普通方法foo，@classmethod修饰的类方法class_foo，还有@staticmethod修饰的静态方法static_foo，那么他们之间有什么区别呢？我们不妨来验证一下： 123456789a=A()print(a.foo)print(a.class_foo)print(a.static_foo)# 输出结果# &lt;bound method A.foo of &lt;__main__.A object at 0x0121B950&gt;&gt;# &lt;bound method A.class_foo of &lt;class '__main__.A'&gt;&gt;# &lt;function A.static_foo at 0x01222078&gt; 我们从输出结果可以看到： foo是绑定在实例a上的，参数self便是实例a本身 class_foo是绑定在class A上的，参数cls指向class A本身 static_foo不绑定在a或者A上，所以没有额外的参数 2. 使用那么使用上有什么区别呢？123456789101112131415a = A()a.foo(1)a.class_foo(1)a.static_foo(1)# A.foo(2) #errorA.class_foo(2)A.static_foo(2)# 输出结果# executing foo(&lt;__main__.A object at 0x0121B950&gt;,1)# executing class_foo(&lt;class '__main__.A'&gt;,1)# executing static_foo(1)# executing class_foo(&lt;class '__main__.A'&gt;,2)# executing static_foo(2) 从上面的代码我们可以看到，使用上的区别： foo是绑定在实例a上的，只能通过实例去调用 class_foo绑定在类A上，可以通过实例a或者类A去调用 static_foo不绑定任何参数，也可以通过实例a或者类A去调用 3. 总结类和实例都是对象，所以它们可以有方法： 实例的方法就叫实例方法。 类的方法就叫类方法。 静态方法就是写在类里的普通方法,必须用类来调用，比如说有一些跟类有关系的功能，但是运行的时候又不需要实例和类参与的函数，这个时候就可以用@staticmethod，因为如果写一堆全局函数，可能后续会变得难以维护。 References： 装饰器@staticmethod和@classmethod有什么区别? [翻译]PYTHON中STATICMETHOD和CLASSMETHOD的差异]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python 装饰器decorator]]></title>
      <url>%2F2016%2F05%2F17%2Fpython-decorator%2F</url>
      <content type="text"><![CDATA[2分钟告诉你什么是python装饰器。 1. 什么是装饰器Python的装饰器的英文名叫Decorator，这个和设计模式中的Decorator Pattern是两种东西。Python中的装饰器主要用于对已经有的模块做一些“修饰工作”。比如说，我们经常需要在函数调用前后自动打印日志，又不想要改变原有函数的模块，这个时候，我们便可以写一个打印log的装饰器。 2. Hello World12345678910111213# 定义log装饰器def log(func): def wrapper(*args, **kw): print('start %s()' % func.__name__) return func(*args, **kw) print('end %s()' % func.__name__) return wrapper@logdef foo(): print('foo function ...')foo() 当运行代码，你会发现有如下输出：1234C:\Users\maoao\Desktop\Project&gt;python Test.pystart foo()foo function ...end foo() 有木有发现很神奇？ 3. Decorator 的本质对于Python的这个@注解语法糖来说，当你在用某个@decorator来修饰某个函数func时，如下所示:123@logdef foo(): print('foo function ...') 相当于执行了语句：1foo = log(foo) 其实就是把一个函数当参数传到另一个函数中，然后再把decorator这个函数的返回值赋值回了原来的func。 不信我们可以做如下验证：123456def fuck(fn): print ("fuck %s ! " % fn.__name__.upper()) @fuckdef gfw(): pass 还没有执行gfw就输出我们每个人的心声了有木有。 知道这点本质，当你看到有多个decorator：1234@decorator_one@decorator_twodef func(): pass 相当于：1func = decorator_one(decorator_two(func)) 带参数的decorator：123@decorator(arg1, arg2)def func(): pass 相当于：1func = decorator(arg1,arg2)(func) 这意味着decorator(arg1, arg2)这个函数需要返回一个“真正的decorator”。 4. 带参数的装饰器示例假设我们可以编写一个带参数的装饰器：123456789101112131415161718192021222324def log(text): def decorator(func): def wrapper(*args, **kw): print('%s, start %s()' % (text, func.__name__)) func(*args, **kw) print('%s, end %s()' % (text, func.__name__)) wrapper.__name__ = func.__name__ return wrapper return decorator@log('SHUN_TAG')def foo(): print('foo function ...')foo()print foo.__name__# 输出：# C:\Users\maoao\Desktop\Project&gt;python Test.py# SHUN_TAG, start foo()# foo function ...# SHUN_TAG, end foo()# foo @@log(‘SHUN_TAG’)实际上会执行如下语句：foo = log(&#39;SHUN_TAG&#39;)(foo)然后最终会返回wrapper函数给foo，另外要记得wrapper.__name__ = func.__name__，防止有些函数签名的代码回报错。 也可以用@functools.wraps(func)来代替上述写法：1234567891011import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s, start %s()' % (text, func.__name__)) func(*args, **kw) print('%s, end %s()' % (text, func.__name__)) return wrapper return decorator 其实也没有什么复杂的东西。 5. class式的 Decorator最后再来看下decorator的class方式，还是看个示例：1234567891011121314151617181920212223class myDecorator(object): def __init__(self, fn): print "inside myDecorator.__init__()" self.fn = fn def __call__(self): self.fn() print "inside myDecorator.__call__()" @myDecoratordef aFunction(): print "inside aFunction()" print "Finished decorating aFunction()" aFunction() # 输出：# inside myDecorator.__init__()# Finished decorating aFunction()# inside aFunction()# inside myDecorator.__call__() 用类的方式声明一个decorator。我们可以看到这个类中有两个成员： 一个是init()，这个方法是在我们给某个函数decorator时被调用，所以，需要有一个fn的参数，也就是被decorator的函数。 一个是call()，这个方法是在我们调用被decorator函数时被调用的。上面输出可以看到整个程序的执行顺序。 6. 总结decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。 References: Python修饰器的函数式编程 廖雪峰的教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何构建一个orm框架？]]></title>
      <url>%2F2016%2F04%2F25%2Fpython-orm%2F</url>
      <content type="text"><![CDATA[ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。 1. 开始之前开始之前，请先掌握python metaclass的知识，请参考我的文章：从Python Metaclass说起 为什么要使用metaclass？因为要编写一个ORM框架，所有的类都只能动态定义，只有使用者才能根据表的结构定义出对应的类来。 掌握了元类的知识后，我们来尝试编写一个ORM框架。首先，假设我们有一个User表，那么我们可能会写出如下代码：1234567891011class User(Model): # 定义类的属性到列的映射： id = IntegerField('id') name = StringField('username') email = StringField('email') password = StringField('password')# 创建一个实例：u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')# 保存到数据库：u.save() 怎么样？我们可以不用直接去操作SQL了，看上去是不是非常简单呢？ 2. 设计Field类接下来我们要定义Field类，它负责保存数据库表的字段名和字段类型： 1234567891011121314class Field(object): def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return '&lt;%s:%s&gt;' % (self.__class__.__name__, self.name)class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, 'varchar(100)')class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, 'bigint') 3. 设计Model类Model类是数据库表类的基类。 在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等： 123456789101112131415161718192021222324252627282930# 创建Model类时，指定通过ModelMetaclass来创建class Model(dict, metaclass=ModelMetaclass): def __init__(self, **kw): print("Model __init__ : ", kw ) super(Model, self).__init__(**kw) def __getattr__(self, key): print("__getattr__: %s &gt; %s" % (key,self[key])) try: return self[key] except KeyError: raise AttributeError(r"'Model' object has no attribute '%s'" % key) def __setattr__(self, key, value): print("__setattr__ : ", key) self[key] = value #只是模拟打印出sql语句 def save(self): fields = [] params = [] args = [] for k, v in self.__mappings__.items(): fields.append(v.name) # id,username,email,password 字段名 params.append('?') # ???? args.append(getattr(self, k, None)) sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params)) print('SQL: %s' % sql) print('ARGS: %s' % str(args)) 4. 设计ModelMetaclass元类最后就是mnetaclass元类的编写了。 使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类: 1234567891011121314151617class ModelMetaclass(type): # 准备创建的类的对象，类名，父类集合，类方法集合 def __new__(cls, name, bases, attrs): print('Found model: %s' % name) if name=='Model': return type.__new__(cls, name, bases, attrs) mappings = dict() for k, v in attrs.items(): if isinstance(v, Field): print('Found mapping: %s ==&gt; %s' % (k, v)) mappings[k] = v for k in mappings.keys(): attrs.pop(k) attrs['__mappings__'] = mappings # 保存属性和列的映射关系 attrs['__table__'] = name # 假设表名和类名一致 return type.__new__(cls, name, bases, attrs) 至此，核心代码基本上写完了，怎么样？看起来也不是很难。我们来梳理一下： 定义一个class User(Model)类 Python解释器通过父类Model的metaclass找到ModelMetaclass类，通过它来创建User ModelMetaclass保存User类的一些信息，比如表名，字段等 当我们调用save()方法时，会去用到第三步骤保存的信息，构造出SQL语句，将数据保存到数据库中 我们编写代码：12u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')u.save() 输出：1234567Found model: UserFound mapping: email ==&gt; &lt;StringField:email&gt;Found mapping: password ==&gt; &lt;StringField:password&gt;Found mapping: id ==&gt; &lt;IntegerField:uid&gt;Found mapping: name ==&gt; &lt;StringField:username&gt;SQL: insert into User (password,email,username,id) values (?,?,?,?)ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345] 可以看到，save()方法打印出了SQL语句和参数列表，我们可以根据自己的需求，来将此信息存储到数据库中。 References: 廖雪峰的教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从Python Metaclass说起...]]></title>
      <url>%2F2016%2F04%2F12%2Fpython-metaclass%2F</url>
      <content type="text"><![CDATA[在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（’Class’）的概念。类也是对象，可以把类看成是元类（’Metaclass’）创建出来的对象。 1. 理解python中的class在理解元类之前，你需要先掌握Python中的类。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。 123456class S(object): passs = S()print (s) # &lt;__main__.S object at 0x00F3B390&gt;print (S) # &lt;class '__main__.S'&gt; 通过以上片段我们可以知道，’s’是一个对象实例，而’S’是一个类。而通过type()我们可以查看它的类型： 12print (type(s)) # &lt;class '__main__.S'&gt;print (type(S)) # &lt;class 'type'&gt; 可以看到s的类型是Class S，而S的类型是type，那么type是什么呢？ 12print(type(S) # &lt;class 'type'&gt;print(type(type)) # &lt;class 'type'&gt; 为什么class的类型是type？？ 2. 理解type动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。事实上，我们说class也是对象，而这个对象是运行时动态创建的，创建class的方法就是使用type()函数。 我们可以打印出help(type) :123456789101112131415Help on class type in module builtins:class type(object) | type(object_or_name, bases, dict) | type(object) -&gt; the object's type | type(name, bases, dict) -&gt; a new type | | Methods defined here: | | __call__(self, /, *args, **kwargs) | Call self as a function. | | __delattr__(self, name, /) | Implement delattr(self, name). | 我们主要看type(name, bases, dict)这个方法，事实上当我们定义class的时候，就是调用此方法来创建class对象的。 12345678910def say_hello(self): print("say hello")name = 'Student' # 类名bases = (object,) # 父类集合attrs = &#123;'say_hello' : say_hello&#125; # 类属性和方法Student = type(name, bases, attrs)s = Student()s.say_hello() 等价于 12345class Student(object): def say_hello(self): print("say hello")s = Student()s.say_hello() 3. 理解metaclassmetaclass，直译为元类，metaclass允许你动态的控制类的创建行为。换句话说，你可以把类看成是metaclass创建出来的“实例”。 因此我们可以先定义metaclass，然后用metaclass创建类，最后用类创建实例。 我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法： 123456789# 1. metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs)# 2. 定义了metaclass，接下来我们要定义类，并指定用metaclass来创建：class MyList(list, metaclass=ListMetaclass): pass 当我们传入关键字参数metaclass时，它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，因此我们在__new__()函数里面修改类的定义，比如，加上新的方法，然后，返回修改后的定义。__new__()方法接收到的参数依次是： 当前准备创建的类的对象 类的名字 类继承的父类集合 类的方法集合即：1234cls ==&gt; `&lt;class '__main__.ListMetaclass'&gt;`name ==&gt; `MyList`bases ==&gt; (&lt;class 'list'&gt;,) attrs ==&gt; &#123;'__qualname__': 'MyList', '__module__': '__main__'&#125; 当返回后，我们可以测试一下MyList类是否有add()方法：123456L = MyList()L.add(1)print(L) ###### 输出 ######[1] 动态修改类行为有什么意义？直接在MyList定义中写上add()方法不是更简单吗？ 正常情况下，确实应该直接写，通过metaclass修改纯属变态。 但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。ORM全称“Object Relational Mapping”，即对象-关系映射。 如果做过java web的同学应当知道，Hibernate就是一个对象关系映射的框架。就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。 下一节，我们会学习如何用python来构建一个ORM框架。 References: StackOverflow 廖雪峰的教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[io-multiplexing-epoll]]></title>
      <url>%2F2016%2F03%2F23%2Fio-multiplexing-epoll%2F</url>
      <content type="text"><![CDATA[什么是epoll？epoll是在2.6内核中提出的，是之前的select和poll的增强版本。它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。 1. epoll的优点？相对于select和poll来说，epoll有如下优点： 支持一个进程打开大数目的socket描述符 select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是1024。对于那些需要支持的上万连接数目的IM服务器来说显然太少了。这时候你一是可以选择修改这个宏然后重新编译服务器代码，不过资料也同时指出这样会带来网络效率的下降。 IO效率不随FD数目增加而线性下降 传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对“活跃”的socket进行操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有“活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会 使用mmap加速内核与用户空间的消息传递 无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核与用户空间mmap同一块内存实现的。 2. epoll使用说明先来看epoll的几个函数：1234#include &lt;sys/epoll.h&gt; int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); int epoll_create(int size);创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。 第一个参数是epoll_create()的返回值 第二个参数表示动作,用三个宏来表示: EPOLL_CTL_ADD：注册新的fd到epfd中； EPOLL_CTL_MOD：修改已经注册的fd的监听事件； EPOLL_CTL_DEL：从epfd中删除一个fd； 第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事。struct epoll_event结构如下： 1234567891011121314151617181920typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64; &#125; epoll_data_t; struct epoll_event &#123; __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ &#125;; //events可以是以下几个宏的集合： EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； EPOLLOUT：表示对应的文件描述符可以写； EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； EPOLLERR：表示对应的文件描述符发生错误； EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。 EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。 3. epoll的两种模式LT和ET二者的差异在于level-trigger模式下只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket；而edge-trigger模式下只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。LT支持阻塞和非阻塞，ET只支持非阻塞，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 返回EAGAIN或者EWOULDBLOCK错误，这个错误表示资源暂时不够，能read时，读缓冲区没有数据，或者write时，写缓冲区满了。 如果是阻塞socket，则会一直阻塞，直到能read或者能write。（当然如果你通过setsockopt设置了读写超时，超时时间到了还是会返回-1和EAGAIN，如果没有设置还是返回-1，则表示网络出错了） 如果是非阻塞socket，则会直接返回-1， 同时errno设置为EAGAIN 所以，在epoll的ET模式下，正确的读写方式为: 读：只要可读，就一直读，直到返回0，或者 errno = EAGAIN 写:只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN 4. epoll,ET模式的简单HTTP服务器代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;sys/socket.h&gt;#include &lt;sys/wait.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt; #define MAX_EVENTS 10#define PORT 8080//设置socket连接为非阻塞模式void setnonblocking(int sockfd) &#123; int opts; opts = fcntl(sockfd, F_GETFL); if(opts &lt; 0) &#123; perror("fcntl(F_GETFL)\n"); exit(1); &#125; opts = (opts | O_NONBLOCK); if(fcntl(sockfd, F_SETFL, opts) &lt; 0) &#123; perror("fcntl(F_SETFL)\n"); exit(1); &#125;&#125;int main()&#123; struct epoll_event ev, events[MAX_EVENTS]; int addrlen, listenfd, conn_sock, nfds, epfd, fd, i, nread, n; struct sockaddr_in local, remote; char buf[BUFSIZ]; //创建listen socket if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123; perror("sockfd\n"); exit(1); &#125; setnonblocking(listenfd); bzero(&amp;local, sizeof(local)); local.sin_family = AF_INET; local.sin_addr.s_addr = htonl(INADDR_ANY);; local.sin_port = htons(PORT); if( bind(listenfd, (struct sockaddr *) &amp;local, sizeof(local)) &lt; 0) &#123; perror("bind\n"); exit(1); &#125; listen(listenfd, 20); epfd = epoll_create(MAX_EVENTS); if (epfd == -1) &#123; perror("epoll_create"); exit(EXIT_FAILURE); &#125; ev.events = EPOLLIN; ev.data.fd = listenfd; if (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) == -1) &#123; perror("epoll_ctl: listen_sock"); exit(EXIT_FAILURE); &#125; for (;;) &#123; nfds = epoll_wait(epfd, events, MAX_EVENTS, -1); if (nfds == -1) &#123; perror("epoll_pwait"); exit(EXIT_FAILURE); &#125; for (i = 0; i &lt; nfds; ++i) &#123; fd = events[i].data.fd; if (fd == listenfd) &#123; while ((conn_sock = accept(listenfd,(struct sockaddr *) &amp;remote, (size_t *)&amp;addrlen)) &gt; 0) &#123; setnonblocking(conn_sock); ev.events = EPOLLIN | EPOLLET; ev.data.fd = conn_sock; if (epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &amp;ev) == -1) &#123; perror("epoll_ctl: add"); exit(EXIT_FAILURE); &#125; &#125; if (conn_sock == -1) &#123; if (errno != EAGAIN &amp;&amp; errno != ECONNABORTED &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR) perror("accept"); &#125; continue; &#125; if (events[i].events &amp; EPOLLIN) &#123; n = 0; while ((nread = read(fd, buf + n, BUFSIZ-1)) &gt; 0) &#123; n += nread; &#125; if (nread == -1 &amp;&amp; errno != EAGAIN) &#123; perror("read error"); &#125; ev.data.fd = fd; ev.events = events[i].events | EPOLLOUT; if (epoll_ctl(epfd, EPOLL_CTL_MOD, fd, &amp;ev) == -1) &#123; perror("epoll_ctl: mod"); &#125; &#125; if (events[i].events &amp; EPOLLOUT) &#123; sprintf(buf, "HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\nHello World", 11); int nwrite, data_size = strlen(buf); n = data_size; while (n &gt; 0) &#123; nwrite = write(fd, buf + data_size - n, n); if (nwrite &lt; n) &#123; if (nwrite == -1 &amp;&amp; errno != EAGAIN) &#123; perror("write error"); &#125; break; &#125; n -= nwrite; &#125; close(fd); &#125; &#125; &#125; return 0;&#125; 5. epoll &amp; LT 模式简单的服务器代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#define IPADDRESS "127.0.0.1"#define PORT 8787#define MAXSIZE 1024#define LISTENQ 5#define FDSIZE 1000#define EPOLLEVENTS 100//函数声明//创建套接字并进行绑定static int socket_bind(const char* ip,int port);//IO多路复用epollstatic void do_epoll(int listenfd);//事件处理函数static voidhandle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf);//处理接收到的连接static void handle_accpet(int epollfd,int listenfd);//读处理static void do_read(int epollfd,int fd,char *buf);//写处理static void do_write(int epollfd,int fd,char *buf);//添加事件static void add_event(int epollfd,int fd,int state);//修改事件static void modify_event(int epollfd,int fd,int state);//删除事件static void delete_event(int epollfd,int fd,int state);int main(int argc,char *argv[])&#123; int listenfd; listenfd = socket_bind(IPADDRESS,PORT); listen(listenfd,LISTENQ); do_epoll(listenfd); return 0;&#125;static int socket_bind(const char* ip,int port)&#123; int listenfd; struct sockaddr_in servaddr; listenfd = socket(AF_INET,SOCK_STREAM,0); if (listenfd == -1) &#123; perror("socket error:"); exit(1); &#125; bzero(&amp;servaddr,sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET,ip,&amp;servaddr.sin_addr); servaddr.sin_port = htons(port); if (bind(listenfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr)) == -1) &#123; perror("bind error: "); exit(1); &#125; return listenfd;&#125;static void do_epoll(int listenfd)&#123; int epollfd; struct epoll_event events[EPOLLEVENTS]; int ret; char buf[MAXSIZE]; memset(buf,0,MAXSIZE); //创建一个描述符 epollfd = epoll_create(FDSIZE); //添加监听描述符事件 add_event(epollfd,listenfd,EPOLLIN); for ( ; ; ) &#123; //获取已经准备好的描述符事件 ret = epoll_wait(epollfd,events,EPOLLEVENTS,-1); handle_events(epollfd,events,ret,listenfd,buf); &#125; close(epollfd);&#125;static voidhandle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)&#123; int i; int fd; //进行选好遍历 for (i = 0;i &lt; num;i++) &#123; fd = events[i].data.fd; //根据描述符的类型和事件类型进行处理 if ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN)) handle_accpet(epollfd,listenfd); else if (events[i].events &amp; EPOLLIN) do_read(epollfd,fd,buf); else if (events[i].events &amp; EPOLLOUT) do_write(epollfd,fd,buf); &#125;&#125;static void handle_accpet(int epollfd,int listenfd)&#123; int clifd; struct sockaddr_in cliaddr; socklen_t cliaddrlen; clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen); if (clifd == -1) perror("accpet error:"); else &#123; printf("accept a new client: %s:%d\n",inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port); //添加一个客户描述符和事件 add_event(epollfd,clifd,EPOLLIN); &#125;&#125;static void do_read(int epollfd,int fd,char *buf)&#123; int nread; nread = read(fd,buf,MAXSIZE); if (nread == -1) &#123; perror("read error:"); close(fd); delete_event(epollfd,fd,EPOLLIN); &#125; else if (nread == 0) &#123; fprintf(stderr,"client close.\n"); close(fd); delete_event(epollfd,fd,EPOLLIN); &#125; else &#123; printf("read message is : %s",buf); //修改描述符对应的事件，由读改为写 modify_event(epollfd,fd,EPOLLOUT); &#125;&#125;static void do_write(int epollfd,int fd,char *buf)&#123; int nwrite; nwrite = write(fd,buf,strlen(buf)); if (nwrite == -1) &#123; perror("write error:"); close(fd); delete_event(epollfd,fd,EPOLLOUT); &#125; else modify_event(epollfd,fd,EPOLLIN); memset(buf,0,MAXSIZE);&#125;static void add_event(int epollfd,int fd,int state)&#123; struct epoll_event ev; ev.events = state; ev.data.fd = fd; epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);&#125;static void delete_event(int epollfd,int fd,int state)&#123; struct epoll_event ev; ev.events = state; ev.data.fd = fd; epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);&#125;static void modify_event(int epollfd,int fd,int state)&#123; struct epoll_event ev; ev.events = state; ev.data.fd = fd; epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);&#125; 至此，epoll的内容介绍完了。 References： Epoll在LT和ET模式下的读写方式 IO多路复用之epoll总结 epoll使用详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[I/O Multiplexing-poll]]></title>
      <url>%2F2016%2F03%2F18%2Fio-multiplexing-poll%2F</url>
      <content type="text"><![CDATA[poll和select实现功能差不多，但poll效率比select效率高。 1. 什么是I/O Multiplexing I / O多路转接(I/O multiplexing),其基本思想是:先构造一张有关描述符的表,然后调用一个函数,它要到这些描述符中的一个已准备好进行 I / O时才返回。在返回时,它告诉进程哪一个描述符已准备好可以进行 I / O。IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。其好处就在于单个process就可以同时处理多个网络连接的IO。 poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 2. poll函数12# include &lt;poll.h&gt; int poll ( struct pollfd * fds, unsigned int nfds, int timeout); timeout == INFTIM 永远等待(INFTIM 通常等于-1) timeout == 0 不等待 timeout &gt; 0 等待ttimeout毫秒 与select不同,poll不是为每个条件构造一个描述符集,而是构造一个pollfd结构数组,每个数组元素指定一个描述符编号以及对其所关心的条件。 12345struct pollfd &#123; int fd ; /* file descriptor to check, or &lt; 0 to ignore */ short events ; /* events of interest on fd */ shortr events ; /* events that occurred on fd */ &#125; ; 简单点儿说，fd对应要监视的文件描述符，events对应需要监视的事件，revents对应实际发生的事件。 返回值和错误代码: 成功时，poll()返回结构体中revents域不为0的文件描述符个数 如果在超时前没有任何事件发生，poll()返回0； 失败时，poll()返回-1，并设置errno为下列值之一： EBADF 一个或多个结构体中指定的文件描述符无效。 EFAULTfds 指针指向的地址超出进程的地址空间。 EINTR 请求的事件之前产生一个信号，调用可以重新发起。 EINVALnfds 参数超出PLIMIT_NOFILE值。 3. 利用poll设计的web服务器设计一个比较简单的web服务器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;poll.h&gt;#define MYPORT 8008 // the port users will be connecting to#define BACKLOG 10 // how many pending connections queue will hold#define BUF_SIZE 200struct pollfd pollfds[BACKLOG + 1];int nfds = 0;void showclient()&#123; int i; printf("client count: %d\n", nfds -1); for (i = 0; i &lt; BACKLOG + 1; i++) &#123; printf("[%d]:%d ", i, pollfds[i].fd); &#125; printf("\n\n");&#125;int main(void)&#123; int sock_fd, new_fd; // listen on sock_fd, new connection on new_fd struct sockaddr_in server_addr; // server address information struct sockaddr_in client_addr; // connector's address information socklen_t sin_size; int yes = 1; char buf[BUF_SIZE]; int ret; int i; if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123; perror("socket"); exit(1); &#125; if (setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1) &#123; perror("setsockopt"); exit(1); &#125; server_addr.sin_family = AF_INET; // host byte order server_addr.sin_port = htons(MYPORT); // short, network byte order server_addr.sin_addr.s_addr = INADDR_ANY; // automatically fill with my IP memset(server_addr.sin_zero, '\0', sizeof(server_addr.sin_zero)); if (bind(sock_fd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) == -1) &#123; perror("bind"); exit(1); &#125; if (listen(sock_fd, BACKLOG) == -1) &#123; perror("listen"); exit(1); &#125; printf("listen port %d\n", MYPORT); sin_size = sizeof(client_addr); for (i = 1; i &lt; BACKLOG + 1; i++) &#123; pollfds[i].fd = -1; &#125; pollfds[0].fd = sock_fd; pollfds[0].events = POLLIN; nfds++; while (1) &#123; ret = poll(pollfds, nfds, -1); if (ret &lt; 0) &#123; perror("poll"); break; &#125; else if (ret == 0) &#123; printf("timeout.\n"); continue; &#125; // add a new client if (pollfds[0].revents &amp; POLLIN) &#123; new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;sin_size); if (new_fd &lt;= 0) &#123; perror("accept"); continue; &#125; for (i = 1; i &lt; BACKLOG + 1; i++) &#123; if (pollfds[i].fd == -1) &#123; pollfds[i].fd = new_fd; pollfds[i].events = POLLIN; printf("add a new client: pollfds[%d] = %d \n",i,new_fd); nfds++; break; &#125; &#125; &#125; // check every client for (i = 1; i &lt; nfds; i++) &#123; if (pollfds[i].revents &amp; POLLIN) &#123; ret = recv(pollfds[i].fd, buf, sizeof(buf), 0); char str[] = "Good,very nice!\n"; send(pollfds[i].fd, str, sizeof(str) + 1, 0); if (ret &lt;= 0) &#123; // client close printf("client[%d] close\n", i); close(pollfds[i].fd); pollfds[i].fd = -1; nfds--; &#125; else &#123; // receive data if (ret &lt; BUF_SIZE) memset(&amp;buf[ret], '\0', 1); printf("client[%d] send:%s\n", i, buf); &#125; &#125; &#125; showclient(); &#125; // close other connections for (i = 0; i &lt; nfds; i++) &#123; if (pollfds[i].fd != 0) &#123; close(pollfds[i].fd); &#125; &#125; exit(0);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[I/O Multiplexing select]]></title>
      <url>%2F2016%2F03%2F17%2Fio-multiplexing-select%2F</url>
      <content type="text"><![CDATA[I / O多路转接(I/O multiplexing),其基本思想是:先构造一张有关描述符的表,然后调用一个函数,它要到这些描述符中的一个已准备好进行 I / O时才返回.在返回时,它告诉进程哪一个描述符已准备好可以进行 I / O。 1. 什么是I/O Multiplexing？I/O multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。其好处就在于单个process就可以同时处理多个网络连接的IO。我们在这里仅仅来讨论select，它的基本原理就是会不断的轮询所负责的所有fdset，当某个fd有数据到达了，就通知用户进程来处理fd的读或者写事件。如果没有fd就绪，select会根据参数选择一直阻塞或者timeout。 I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。 2. select函数说明12345int select(int maxfd,fd_set *readfds,fd_set *writefds, fd_set *exceptfds,struct timeval *timeout); //maxfd 是需要监视的最大的文件描述符值+1//readfds 需要检测的可读文件描述符的集合//writefds 可写文件描述符的集合//exceptfds 异常文件描述符的集合 下面的宏提供了处理这三种fd_set的方式: FD_CLR(inr fd,fd_set set)；用来清除描述词组set中相关fd 的位FD_ISSET(int fd,fd_set set)；用来测试描述词组set中相关fd 的位是否为真FD_SET（int fd,fd_setset）；用来设置描述词组set中相关fd的位FD_ZERO（fd_set set）；用来清除描述词组set的全部位 另外： 1234struct timeval&#123; long tv_sec; /* seconds */ long tv_usec; /* and microseconds */&#125;; 如果参数timeout设为： NULL，则表示select（）没有timeout，select将一直被阻塞，直到某个文件描述符上发生了事件 0：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生 特定的时间值：如果在指定的时间段里没有事件发生，select将超时返回 3. select函数返回值执行成功则返回文件描述词状态已改变的个数，如果返回0代表在描述词状态改变前已超过timeout时间，没有返回；当有错误发生时则返回-1，错误原因存于errno，此时参数readfds，writefds，exceptfds和timeout的值变成不可预测。错误值可能为：1234// EBADF 文件描述词为无效的或该文件已关闭// EINTR 此调用被信号所中断// EINVAL 参数n 为负值。// ENOMEM 核心内存不足 4.理解Select模型：例如,我们若编写下列代码:12345678fd_set readset, writeset;FD_ZERO(&amp;readset) ;FD_ZERO(&amp;writeset) ;FD_SET(0, &amp;readset);FD_SET(3, &amp;readset);FD_SET(1, &amp;writeset);FD_SET(2, &amp;writeset);select (4, &amp;readset, &amp;writeset, NULL, NULL); 那么对应的fd_set模型为： 5. 如何利用select设计的web服务器：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #define MYPORT 88960 // the port users will be connecting to #define BACKLOG 10 // how many pending connections queue will hold #define BUF_SIZE 200 int fd_A[BACKLOG]; // accepted connection fd int conn_amount; // current connection amount void showclient() &#123; int i; printf("client amount: %d\n", conn_amount); for (i = 0; i &lt; BACKLOG; i++) &#123; printf("[%d]:%d ", i, fd_A[i]); &#125; printf("\n\n"); &#125; int main(void) &#123; int sock_fd, new_fd; // listen on sock_fd, new connection on new_fd struct sockaddr_in server_addr; // server address information struct sockaddr_in client_addr; // connector's address information socklen_t sin_size; int yes = 1; char buf[BUF_SIZE]; int ret; int i; if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123; perror("socket"); exit(1); &#125; if (setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1) &#123; perror("setsockopt"); exit(1); &#125; server_addr.sin_family = AF_INET; // host byte order server_addr.sin_port = htons(MYPORT); // short, network byte order server_addr.sin_addr.s_addr = INADDR_ANY; // automatically fill with my IP memset(server_addr.sin_zero, '\0', sizeof(server_addr.sin_zero)); if (bind(sock_fd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) == -1) &#123; perror("bind"); exit(1); &#125; if (listen(sock_fd, BACKLOG) == -1) &#123; perror("listen"); exit(1); &#125; printf("listen port %d\n", MYPORT); fd_set fdsr; int maxsock; struct timeval tv; conn_amount = 0; sin_size = sizeof(client_addr); maxsock = sock_fd; while (1) &#123; // initialize file descriptor set FD_ZERO(&amp;fdsr); FD_SET(sock_fd, &amp;fdsr); // timeout setting tv.tv_sec = 30; tv.tv_usec = 0; // add active connection to fd set for (i = 0; i &lt; BACKLOG; i++) &#123; if (fd_A[i] != 0) &#123; FD_SET(fd_A[i], &amp;fdsr); &#125; &#125; ret = select(maxsock + 1, &amp;fdsr, NULL, NULL, &amp;tv); if (ret &lt; 0) &#123; perror("select"); break; &#125; else if (ret == 0) &#123; printf("timeout\n"); continue; &#125; // check every fd in the set for (i = 0; i &lt; conn_amount; i++) &#123; if (FD_ISSET(fd_A[i], &amp;fdsr)) &#123; ret = recv(fd_A[i], buf, sizeof(buf), 0); char str[] = "Good,very nice!\n"; send(fd_A[i],str,sizeof(str) + 1, 0); if (ret &lt;= 0) &#123; // client close printf("client[%d] close\n", i); close(fd_A[i]); FD_CLR(fd_A[i], &amp;fdsr); fd_A[i] = 0; &#125; else &#123; // receive data if (ret &lt; BUF_SIZE) memset(&amp;buf[ret], '\0', 1); printf("client[%d] send:%s\n", i, buf); &#125; &#125; &#125; // check whether a new connection comes if (FD_ISSET(sock_fd, &amp;fdsr)) &#123; new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;sin_size); if (new_fd &lt;= 0) &#123; perror("accept"); continue; &#125; // add to fd queue if (conn_amount &lt; BACKLOG) &#123; fd_A[conn_amount++] = new_fd; printf("new connection client[%d] %s:%d\n", conn_amount, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); if (new_fd &gt; maxsock) maxsock = new_fd; &#125; else &#123; printf("max connections arrive, exit\n"); send(new_fd, "bye", 4, 0); close(new_fd); break; &#125; &#125; showclient(); &#125; // close other connections for (i = 0; i &lt; BACKLOG; i++) &#123; if (fd_A[i] != 0) &#123; close(fd_A[i]); &#125; &#125; exit(0); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一步一步搭建hexo博客]]></title>
      <url>%2F2016%2F02%2F23%2Fhexo-blog%2F</url>
      <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 准备环境因为我是在windows下，所以需要先安装Git和Node.js： Git for windows Node.js安装过程就不多说了。 安装Hexo打开git，cd到你需要安装hexo的目录，然后安装hexo 1npm install -g hexo-cli 初始化Hexo项目创建并且初始化hexo项目123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install hexo默认的目录如下：12345678910├── .deploy_git├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json 目录 描述 .deploy_git 执行hexo deploy命令部署到GitHub上的内容目录 public 执行hexo generate命令，输出的静态网页内容目录 scaffolds layout模板文件目录，其中的md文件可以添加编辑 scripts 扩展脚本目录，这里可以自定义一些javascript脚本 source 文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon，ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts 草稿文章 _posts 发布文章 themes 主题文件目录 _config.yml 全局配置文件，大多数的设置都在这里 package.json 应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 hexo 命令常用几个命令：12345hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHub 更换next主题12cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改站点配置文件_config.yml：1theme: next 更多关于next主题可以参考： 使用文档 next常见问答 安装插件hexo支持插件，可以直接通过命令行安装即可：12345npm install plugin-name --save//更新插件npm update//卸载插件npm uninstall plugin-name 下面推荐几个常用的插件：123456//feed插件npm install hexo-generator-feed --save//站点地图npm install hexo-generator-sitemap --save//百度站点地图npm install hexo-generator-baidu-sitemap --save 然后在 Hexo 根目录下的 _config.yml 里配置一下：12345678feed: type: atom path: atom.xml limit: 20 # 最近20篇文章 sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml SEO增加主页关键词更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 百度收录（1）网站验证 先到百度站长注册账号，并且添加网站，然后进行网站验证，我们通过html标签验证，next主题已经给我们做好了： 打开_config.yml:1baidu_site_verification: ***** 然后hexo deploy后，点击完成验证即可。 （2）提交baidusitemap.xml 打开百度站长工具，网页抓取-链接提交栏下，选择自动提交： 主动推送 最为快速的提交方式，将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。需要改写url链接带参数，操作起来不好搞，放弃。 自动推送 需要嵌入一段js代码，当我们每访问一次网站，则自动运行脚本，推送链接到百度 （next主题也为我们做好了） sitemap：自动提交baidusitemap.xml （3）自动推送 打开_config.yml：1baidu_push: true 打开hexo-blog/themes/next/layout/_scripts/baidu-push.swig，替换为百度给我们的js代码：12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; 谷歌收录（1）网站验证 验证方式基本一样，打开_config.yml: 1google_site_verification: ******* （2）提交sitemap 点击站点地图，提交sitemap.xml即可，比较简单。 同时使用coding和github补充一下，因为百度对github page不太友好，如果博客托管在github page上，很难被百度收录。所以我们可以把网站托管到coding平台，即同时使用Coding提供的Pages服务和Github提供的Pages服务 安装deploy git： 1npm install hexo-deployer-git --save 配置_config.yml： 123456deploy: type: git repo: git@github.com:Maoao530/Maoao530.github.io.git coding: https://git.coding.net/xxxxxx,coding-pages branch: master 配置完成后直接hexo deploy,就可以了。 国内国外访问不同的Pages服务如果托管到coding pages后，那么域名当然也和github pages不一样了，那么怎么办呢？ 去dnspod买个域名，我们可以通过DnsPod让国内用户访问coding，让国外用户访问github。然后我们只要访问这个域名即可。]]></content>
    </entry>

    
  
  
</search>
